{"meta":{"title":"blog","subtitle":null,"description":"my blog","author":"tongxiang","url":"http://cansolve.cn"},"pages":[{"title":"全部分类","date":"2018-12-13T08:13:11.000Z","updated":"2018-12-13T08:13:11.000Z","comments":false,"path":"categories/index.html","permalink":"http://cansolve.cn/categories/index.html","excerpt":"","text":""},{"title":"推荐链接","date":"2018-12-20T08:40:36.844Z","updated":"2018-12-20T08:40:36.844Z","comments":true,"path":"links/index.html","permalink":"http://cansolve.cn/links/index.html","excerpt":"","text":""},{"title":"全部标签","date":"2018-12-13T08:13:04.000Z","updated":"2018-12-13T08:13:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://cansolve.cn/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-12-13T08:15:25.000Z","updated":"2018-12-13T08:15:25.000Z","comments":false,"path":"about/index.html","permalink":"http://cansolve.cn/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"常见jquery方法汇总","slug":"daily19","date":"2019-03-22T02:36:19.000Z","updated":"2019-03-22T02:06:14.640Z","comments":true,"path":"2019/03/22/daily19/","link":"","permalink":"http://cansolve.cn/2019/03/22/daily19/","excerpt":"","text":"最近前后端分离模式写的也少了，因为公司做的游戏网站都是面向全球的，涉及到ssr，根据业务及人员需求，采用php渲染的方式，于是我这边又回到了一个切图仔的身份，完成布局，写点交互效果就好了，好了不说了，有点惨，这里总结一下常用的jq方法，其实也是为了自己方便查阅，哈哈！！jQuery 语法$(selector).action()文档加载就绪事件12345678$(document).ready(function() &#123; // 代码...&#125;);// 简写方式$(function() &#123; // 代码...&#125;);$(document).ready 与 window.onload 的区别$(document).ready 和 window.onload 都是在都是在页面加载完执行的函数，大多数情况下差别不大。$(document).ready:是 DOM 结构绘制完毕后就执行，不必等到加载完毕。 意思就是 DOM 树加载完毕，就执行，不必等到页面中图片或其他外部文件都加载完毕。并且可以写多个.ready。window.onload:是页面所有元素都加载完毕，包括图片等所有元素。只能执行一次。选择器jQuery 选择器基于已经存在的 CSS 选择器$(‘*’)​$(‘p’)$(‘ul li’)…事件click() 点击事件dbclick() 双击事件mouseenter() 鼠标穿过元素事件mouseleave() 鼠标离开元素事件mousedown() 鼠标移动到元素上方按下鼠标事件mouseup() 鼠标按住移动到元素上方松开鼠标事件hover() 鼠标悬停事件focus() 表单元素聚焦事件blur() 表单元素失去焦点事件submit() 表单提交事件change() 表单元素值改变事件keypress() 键盘键按住事件keydown() 键盘键按下事件keyup() 键盘键松开事件load() 指定元素加载完成式执行事件 （1.8 版本后废弃）resize() 窗口大小改变事件scroll() 滚动监听事件效果$(selector).action(speed,callback)显示隐藏hide() 隐藏元素show() 显示元素toggle() 显示被隐藏的元素，隐藏已显示的元素淡入淡出fadeIn() 淡入fadeOut() 淡出fadeToggle() 已淡出的元素淡入，已淡入的元素淡出fadeTo() 渐变为给定不透明度$(selector).fadeTo(speed,opacity,callback);opacity 值为 0 与 1 之间滑动slideDown() 向下滑动展开元素slideDown() 向上滑动收起元素slideToggle() 已展开元素上滑收起，已收起元素下滑展示动画$(selector).animate({params},speed,callback);实例12345678$(&quot;button&quot;).click(function() &#123; $(&quot;div&quot;).animate(&#123; left: &quot;250px&quot;, opacity: &quot;0.5&quot;, height: &quot;150px&quot;, width: &quot;150px&quot; &#125;);&#125;);停止动画$(selector).stop(stopAll, goToEnd);jQuery 链(Chaining)jQuery支持在一条语句中运行多个 jQuery 方法（在相同的元素上，浏览器就不必多次查找相同的元素。123456$(&quot;#p1&quot;) .css(&quot;color&quot;, &quot;red&quot;) .slideUp(2000) .slideDown(2000);// &quot;p1&quot; 元素首先会变为红色，然后向上滑动，再然后向下滑动获取内容text() 设置或返回所选元素的文本内容html() 设置或返回所选元素的内容（包括 HTML 标记）val() 设置或返回表单字段的值获取属性attr() 设置或者返回所选的属性的值123456789101112131415161718// 获取属性$(&apos;#test&apos;).attr(&apos;href&apos;）// 设置属性$(&apos;#test&apos;).attr(&apos;href&apos;,&apos;http://www.baidu.com&apos;)$(&apos;#test&apos;).attr(&#123; href: &apos;http://www.baidu.com&apos;, title: &apos;百度&apos;&#125;)// 回掉函数$(&apos;#test&apos;).attr(&apos;href&apos;, function(i, origValue)&#123; // i 被选元素列表中当前元素的下标 // origValue 原始值 return origValue + &apos;/jquery&apos; &#125;)添加删除元素append() 在被选元素的结尾插入内容prepend() 在被选元素的开头插入内容after() 在被选元素之后插入内容before() 在被选元素之前插入内容remove() 删除被选元素（及其子元素）empty() 从被选元素中删除子元素$(‘p’).remove(‘.italic’)获取并设置 css 类addClass() 向被选元素添加一个或多个类removeClass() 从被选元素删除一个或多个类toggleClass() 对被选元素进行添加/删除类的切换操作css() 设置或返回样式属性1234567// 返回样式属性$(&quot;p&quot;).css(&quot;background-color&quot;);// 设置样式属性$(&quot;p&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;);// 或者$(&quot;p&quot;).css(&#123; &quot;background-color&quot;: &quot;yellow&quot;, &quot;font-size&quot;: &quot;200%&quot; &#125;);尺寸方法width() 元素宽度height() 元素高度innerWidth() 包含 padding 宽度innerHeight() 包含 padding 高度outerWidth() 包含 padding、border 宽度outerHeight() 包含 padding、border 高度outerWidth(true) 包含 padding、border、margin 宽度outerHeight(true) 包含 padding、border、margin 高度元素遍历祖先元素：parent() 返回被选元素的直接父元素，该方法只会向上一级对 DOM 树进行遍历。parents() 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。parentsUntil() parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。12345$(document).ready(function() &#123; // div &gt; ul &gt; li &gt; span $(&quot;span&quot;).parentsUntil(&quot;div&quot;); // 返回 ul 和 li&#125;);后代元素：children() 返回被选元素的所有直接子元素。find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。123$(document).ready(function() &#123; $(&quot;div&quot;).find(&quot;span&quot;);&#125;);同胞元素：siblings() 返回被选元素的所有同胞元素。next() 返回被选元素的下一个同胞元素。nextAll() 返回被选元素的所有跟随的同胞元素。nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素。prev() 返回被选元素的上一个同胞元素。prevAll() 返回被选元素之前的所有的同胞元素。prevUntil() 返回介于两个给定参数之间的所有前方的同胞元素。元素过滤：first() 返回被选元素的首个元素。last() 返回被选元素的最后一个元素。eq() 返回被选元素中带有指定索引号的元素。filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。not() 方法返回不匹配标准的所有元素。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://cansolve.cn/tags/其他/"}]},{"title":"移动端常见问题集锦","slug":"daily18","date":"2019-03-15T05:36:19.000Z","updated":"2019-03-19T01:03:54.504Z","comments":true,"path":"2019/03/15/daily18/","link":"","permalink":"http://cansolve.cn/2019/03/15/daily18/","excerpt":"","text":"好像有好久没有写总结了，刚好最近在做移动端的h5比较多，于是就收集了一下坑，并记录了下来给大家参考一下，希望对大家有所帮助，如果没有的话或者哪里写错的，希望各位大佬提出意见，小弟立马查阅并修正。移动端的坑真的是非常的多，毕竟机型太多了，这已经是我整理的第三篇关于移动端问题了，踩坑路漫漫，话不多说，开始移动端ios下$(‘body’)点击无效的解决方法今天遇到一个坑，嵌入到游戏中的h5页面出现按钮点击失效问题正常是这样的1234567$(&apos;body&apos;).click(function(e) &#123; var target = $(e.target); if (!target.is(&apos;#more&apos;) &amp;&amp; !target.is(&apos;.btns *&apos;)) &#123; $(&apos;.btns&apos;).removeClass(&apos;open&apos;); $(&apos;#more&apos;).show(); &#125;&#125;);但是你会发现正常的pc和安卓显示中可以实现，但是在ios真机中显示有问题，因为IOS浏览器的window、document、body并不接受click事件，按钮和链接才接受click事件;度娘了一下有人说给body加cursor：pointer;然并卵;后面实践发现下面的写法会解决123$(&apos;body&gt;*&apos;).bind(&apos;click&apos;, function(e) &#123;...&#125;);或者1234567$(&apos;btn&apos;).bind(&apos;click&apos;,function(e)&#123; //点击按钮显示 $(&apos;#more&apos;).show(); $(&apos;body&apos;).one(&apos;click&apos;,function()&#123; //这里给body执行一次点击后删除事件 $(&apos;#more&apos;).hide(); &#125;) e.stopPropagation(); //这里阻止一下冒泡，因为按钮也在body里面，不让body检测到点击按钮&#125;)这样应该挺好懂吧，可以试试解决：初步解决方案是给body或者html添加overflow：hidden样式，当然height要设置成100%1234567891011$(&quot;#showProup&quot;).click(function() &#123; $(&quot;#mask&quot;).show(0,function()&#123; $(&quot;body&quot;).css(&apos;overflow&apos;,&apos;hidden&apos;); &#125;); &#125;) $(&quot;#close&quot;).click(function() &#123; $(&quot;#mask&quot;).hide(0,function()&#123; $(&quot;body&quot;).css(&apos;overflow&apos;,&apos;scroll&apos;); &#125;); &#125;)&#125;移动端问题比较明显，所以可以touchmove代替123$(document).on(&quot;touchmove&quot;,function(e) &#123; e.preventDefault(); &#125;)这种方法在移动端是可以解决滑动的问题，但有种情景就显得有点尴尬了，移动端屏幕本来就小，如果弹窗的内容过多也需要滑动（比如很长的活动规则），因为弹窗出现的时候已经禁止了滑动事件，此时禁止滑动之前先做一下判断—12345$(document).on(&quot;touchmove&quot;,function(e) &#123; if(e.target.className.indexOf(&quot;shadeBox&quot;) &gt;= 0) &#123; e.preventDefault(); &#125; &#125;)以上为想到的初步方案，如有更好可替换解决：用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果1234a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only;&#125;问题：移动端视频播放（安卓）总在最高层，会挡住遮罩层解决：（初步）点开遮罩的同时隐藏video标签，关闭遮罩时在显示，达到视觉上遮挡问题：移动端点击出现300ms延迟解决：页面引用fastclick.js来避免1FastClick.attach(document.body);问题：Android 上圆形图片使用 border 时，边框显示变形解决：给 img 外嵌套一个元素，为其使用圆角123&lt;div&gt; &lt;img src=&quot;&quot;&gt;&lt;/div&gt;12345678div&#123; display: inline-block; border-radius: 50%; border: 4px solid #FF7000;&#125;img&#123; vertical-align: top;&#125;问题：Android 上圆角元素，背景颜色会溢出解决：123&#123; background-clip: padding-box;&#125;问题： Android 上圆角使用 Animation 做 loading 动画时，圆角背景色溢出的bug解决：12345&#123; background-color: #F9CEAC; border-radius: 32px 0 0 32px; -webkit-mask-image: url(http://i.gtimg.cn/qqlive/images/20150527/btn_mask.png);&#125;原理是使用一个圆角的蒙板通过-webkit-mask-image遮住多余的部分。蒙板：问题：CSS 三角在 Android 上显示为方块解决：可能是对这个三角使用了圆角，去掉border-radius即可12345&#123; border: 10px solid transparent; border-left-color: #000; /*border-radius: 2px;*/&#125;问题： Android 上使用 svg 作为 background-image 时显示模糊解决：设置background-size1234&#123; -webkit-background-size: 100%; background-size: 100%;&#125;问题： :active 样式不生效解决：如果给按钮定义 :hover 样式，在 iPhone 上按钮点击一次是 hover 态，再点击一次 hover 态才会消失，这显然不是我们想要的，继而想通过定义 :active 样式来实现按钮按下时的效果，但发现定义的 active 样式在 iPhone 上点击时没有任何效果。 搜索后发现，只需添加一段 js 即可：1document.addEventListener(&quot;touchstart&quot;, function() &#123;&#125;,false);另一个方案，可以在 body 上添加ontouchstart=&quot;&quot;原因：Safari 默认禁用了元素的active样式，我们通过声明touchstart来覆盖默认事件，就可以让active样式重新激活。问题： 移动端多行文字超出截断需要出现省略号解决：单行文本截断并末尾出现省略号一般写法是：123white-space: nowrap;overflow: hidden;text-overflow: ellipsis;webkit 私有属性在移动端的兼容性不错， iOS 与 Android 均有不错的支持12345display: -webkit-box;overflow: hidden;text-overflow: ellipsis;-webkit-line-clamp: 2;-webkit-box-orient: vertical;其中的-webkit-line-clamp: 2即用来控制文本超出两行时截断并出现省略号。 在使用中如果出现第三行文字露一点头出来的问题，设置合理的line-height即可解决。多行省略号用在 a 链接中时会有一个bug，省略号出现在文字中间：这个问题的解决方案是，不要将多行省略的属性写在 a 上（或其父标签）。而在 a 内再嵌套一个标签，对其使用多行省略。1面对这些问题面对这些，问题面对这些问题面对这些问题面1234567a div&#123; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125;问题： 1px 线条、边框解决：使用高度为 1px ，一半为实色，一半为透明的渐变背景实现1234&#123; background: -webkit-linear-gradient(top, transparent, transparent 50%, #CACDD0 50%) 0 top no-repeat; background-size: 100% 1px;&#125;如果需要有四个边框都有 1px 的线框，可以使用多背景图12345678&#123; background: -webkit-linear-gradient(top, #CACDD0, #CACDD0 50%, transparent 50%, transparent 100%) 0 top no-repeat, -webkit-linear-gradient(top, transparent, transparent 50%, #CACDD0 50%, #CACDD0 100%) 0 bottom no-repeat, -webkit-linear-gradient(left, #CACDD0, #CACDD0 50%, transparent 50%, transparent 100%) left 0 no-repeat, -webkit-linear-gradient(left, transparent, transparent 50%, #CACDD0 50%, #CACDD0 100%) right 0 no-repeat; background-size: 100% 1px,100% 1px, 1px 100%, 1px 100%;&#125;问题：滚动条滚动时没有像 iOS 原生那么顺滑流畅，滚动条没有 iOS 回弹效果解决：1234&#123; overflow: auto; -webkit-overflow-scrolling: touch;&#125;注：在 Android 上由于原生滚动没有回弹效果，所以这里也不会有回弹的效果。问题：当模块使用系统的横向滚动时，不想显示出系统的滚动条样式解决：Android：123::-webkit-scrollbar&#123; opacity: 0;&#125;iOS 要隐藏滚动条，会稍微复杂一些1234567891011.wrap&#123; height: 100px; overflow: hidden;&#125;.box&#123; width: 100%; height: -webkit-calc(100% + 5px); overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch;&#125;原理：.box元素的横向滚动条通过其外层元素.wrap的overflow:hide来隐藏。 （5px 是 iOS 上滚动条元素的高度）问题：横向滚动的元素，滑动时有时图片显示不出来/文字显示不出来解决：给每个横滑的元素块使用硬件加速123li&#123; -webkit-transform: translateZ(0);&#125;问题：使用 animation 动画后，页面上 overflow:auto 的元素滚动条不能滑动解决：不使用 translate 方式的动画，换为使用 left/top 来实现元素移动的动画问题： 上下滑动页面时候，页面元素消失解决：检查是否使用了 fadeIn 的 animation，如有则 fill-mode 使用 backwards 模式123&#123; -webkit-animation: fadeIn 0.5s ease backwards;&#125;问题：页面上数字自动变成了可以点击的链接解决：在页面&lt;head&gt;里添加1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;问题：input 在 iOS 中圆角、内阴影去不掉解决：1234input&#123; -webkit-appearance: none; border-radius: 0;&#125;问题：焦点在 input 时，placeholder 没有隐藏解决：123input:focus::-webkit-input-placeholder&#123; opacity: 0;&#125;问题： input 输入框调出数字输入键盘解决123&lt;input type=&quot;number&quot; /&gt;&lt;input type=&quot;number&quot; pattern=&quot;[0-9]*&quot; /&gt;&lt;input type=&quot;tel&quot; /&gt;分别对应下图中的1、2、3。需要注意的是，单独使用type=&quot;number&quot;时候， iOS 上出现并不是九宫格的数字键盘，如果需要九宫格的数字键盘，可选择使用 2、3 的方法。 1、2、3 在 Android 上均可以唤起九宫格的数字键盘问题：搜索时，键盘的回车按钮文字设定为“搜索”解决：input使用type=&quot;search&quot;，放在form表单内。两者结合就能使输入法中的回车按钮文字变为“搜索”123&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;search&quot; /&gt;&lt;/form&gt;问题：iframe 在 iOS 上没有滚动条，直接撑出去解决：给 iframe 外嵌套一个 div， 为这个 div 设置固定高度与overflow12345div&#123; height: 100px; overflow: auto; -webkit-overflow-scrolling: touch;&#125;","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.cn/tags/移动端/"}]},{"title":"聊聊你可能并没有完全掌握的 (font-family)和粗细(font-weight)问题","slug":"daily17","date":"2019-01-25T08:31:31.000Z","updated":"2019-02-27T06:32:10.685Z","comments":true,"path":"2019/01/25/daily17/","link":"","permalink":"http://cansolve.cn/2019/01/25/daily17/","excerpt":"","text":"谈到“CSS中的字体”，老生常谈的话题了，在平时工作中，完成一个项目，从设计稿到页面最终的输出效果，就字体方面来说，细心的童鞋会发现有很多方面细活要去做的，当然了，这是建立在项目本身要求非常高的情况下。今天下午从两方面来讨论：设置(font-family)和粗细(font-weight)。字体设置(font-family)在写全局样式时，我们都会去设置一个默认的字体，举个例子：font-family:’PingFang SC’,’Microsoft YaHei’,’SimSun’,’Arial’, sans-serif上面的设置，会按照设置的顺序首选字体是平方字体，如没平方字体，就是显示微软雅黑，依次类推…在设置一些中文字体的时候，不建议直接使用中文，还是回归到统一的英文，在这里分享一些常用中文转英文的字体：华文细黑：STHeiti Light [STXihei]华文黑体：STHeiti华文楷体：STKaiti华文宋体：STSong华文仿宋：STFangsong儷黑 Pro：LiHei Pro Medium儷宋 Pro：LiSong Pro Light標楷體：BiauKai苹果丽中黑：Apple LiGothic Medium苹果丽細宋：Apple LiSung LightWindows的一些：新細明體：PMingLiU細明體：MingLiU標楷體：DFKai-SB黑体：SimHei宋体：SimSun新宋体：NSimSun仿宋：FangSong楷体：KaiTi仿宋_GB2312：FangSong_GB2312楷体_GB2312：KaiTi_GB2312微軟正黑體：Microsoft JhengHei微软雅黑体：Microsoft YaHei装Office会生出来的一些：隶书：LiSu幼圆：YouYuan华文细黑：STXihei华文楷体：STKaiti华文宋体：STSong华文中宋：STZhongsong华文仿宋：STFangsong方正舒体：FZShuTi方正姚体：FZYaoti华文彩云：STCaiyun华文琥珀：STHupo华文隶书：STLiti华文行楷：STXingkai华文新魏：STXinwei–可以收藏一波–由于移动端设备过多，默认字体也会很多，首先得去了解他们的默认有哪些：ios 系统默认中文字体是Heiti SC默认英文字体是Helvetica默认数字字体是HelveticaNeue无微软雅黑字体android 系统默认中文字体是Droidsansfallback默认英文和数字字体是Droid Sans无微软雅黑字体winphone 系统默认中文字体是Dengxian(方正等线体)默认英文和数字字体是Segoe无微软雅黑字体这时候你会发现无论是ios、android还是wp系统中都是没有微软雅黑字体的，而且你要是做一个测试你会发现，无论页面中使用哪种字体，肉眼很难看出它们的差异，对产品的体验几乎没有影响。结论：各个手机系统有自己的默认字体，且都不支持微软雅黑。如无特殊需求，手机端无需定义中文字体，使用系统默认。英文字体和数字字体可使用 Helvetica ，三种系统都支持。OK，证据确凿。如果设计师需要用到一些特殊的英文字体，比如漂亮的din1451a，akzidenzgrotesk-cond等，我们需要转换下，然后用@font-face引用下即可，这个方法不多说。字体粗细(font-weight)首先我们了解下font-weight的基本属性值，如下表格：值描述normal默认值。定义标准的字符。bold定义粗体字符。bolder定义更粗的字符。lighter定义更细的字符。100200300400500600700800900| 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 || inherit | 规定应该从父元素继承字体的粗细。 |切记：400等同于normal，而700等同于bold。inherit规定应该从父元素继承字体的粗细。不过感觉效果不明显。只能换个字体试试。不过比较常见的中文字体里，感觉黑体比较粗些吧。我们看个简单的例子，WINDOWS系统PC端效果：对应的CSS字体设置：1234.p1&#123;font:30px Pingfang SC&#125; .p2&#123;font:300 30px Pingfang SC&#125; .p3&#123;font:bold 30pxPingfang SC&#125; .p4&#123;font:900 30px Pingfang SC&#125;123456789101112131415161718192021&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .p1&#123;font:30px Pingfang SC&#125; .p2&#123;font:300 30px Pingfang SC&#125; .p3&#123;font:bold 30px Pingfang SC&#125; .p4&#123;font:900 30px Pingfang SC&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;p1&quot;&gt;Web前端之家&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;Web前端之家&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;Web前端之家&lt;/p&gt; &lt;p class=&quot;p4&quot;&gt;Web前端之家&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;可以根据值的设置，你会发现pc上基本就是那几个明显的变化，我要说的重点是在移动端。如果你对安卓和IOS前期的版本有了解的话，发现它们对于字体加粗属性很乱，支持性不太好，无论你怎么设置都无效，说白了就是系统BUG，^_^。现在安卓和IOS的新版改善了好多，下面截图是安卓7.11和IOS11.2效果：从上图发现，安卓的字体效果要比IOS要粗（请忽视字体大小），这个跟系统默认的字体有直接关系，可能也有其他的原因（请大神赐教）。这里要提醒下：有时候我们设置了加粗的样式，但是实际并没有加粗的效果，为什么呢？很有可能就是font-weight的基础属性值设置问题，400 700这些坎，上面有提到。经验总结CSS字体设置(font-family)和粗细(font-weight)在不同设备和系统下的差别，工作中经常会碰到用一个特殊字符：五角星，箭头，圆点，箭头等等，用字体直接去设置效果，最终出来的效果出来不尽人意，这里建议就是用CSS3、图和base64等。OK，大概就这么多，有啥不对的欢迎来喷。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://cansolve.cn/tags/其他/"}]},{"title":"日常问题解决（持续更新中）","slug":"daily16","date":"2019-01-02T13:06:28.000Z","updated":"2019-03-21T03:01:06.071Z","comments":true,"path":"2019/01/02/daily16/","link":"","permalink":"http://cansolve.cn/2019/01/02/daily16/","excerpt":"","text":"解决使用 swiper 常见的问题1、swiper近视初始化时, 其父级元素处于隐藏状态(display:none),会导致swiper初始化失败, 页面中的滚动效果有问题12345678910111213解决方法1: var mySwiper = new Swiper(&apos;.demo&apos;,&#123; observer: true,//修改swiper自己或子元素时，自动初始化swiper observeParents: true//修改swiper的父元素时，自动初始化swiper &#125;); 解决方法2: 固定宽和高 var mySwiper = new Swiper(&apos;.demo&apos;,&#123; width:200, height:200 &#125;);2、swiper里面的图片懒加载与预加载, 可以使用自带的 lazyload 方法主要看这里-swiper4 懒加载文档12345678910111213141516设为true开启图片延迟加载默认值，使preloadImages无效。或者设置延迟加载选项。 图片延迟加载：需要将图片img标签的src改写成data-src，并且增加类名swiper-lazy。背景图延迟加载：载体增加属性data-background，并且增加类名swiper-lazy。 还可以加一个预加载，&lt;div class=&quot;swiper-lazy-preloader&quot;&gt;&lt;/div&gt;或者白色的&lt;div class=&quot;swiper-lazy-preloader swiper-lazy-preloader-white&quot;&gt;&lt;/div&gt; 当你设置了slidesPerView:&apos;auto&apos; 或者 slidesPerView &gt; 1，还需要开启watchSlidesVisibility。 var mySwiper = new Swiper(&apos;.swiper-container&apos;, &#123; lazy: &#123; loadPrevNext: true, &#125;,&#125;);3、想在轮播图外创建分页器、上一页和下一页的按钮(因为swiper的container默认overflow:hidden, 只能在轮播图中的可视区域显示切换菜单和上一页下一页)1234var mySwiper = new Swiper(&apos;.swiper-container&apos;,&#123; pagination : &apos;.swiper-pagination&apos;, uniqueNavElements :false,&#125;)jquery fullpage 插件增加头部和底部的方法官方给出了解决方案，不要去什么修改源码啦之类的，或者自己写代码判断啦12345678&lt;div class=&quot;fullpage&quot;&gt; &lt;div class=&quot;section fp-auto-height&quot;&gt;这里写头部&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;page1&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;page2&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;page3&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;page4&lt;/div&gt; &lt;div class=&quot;section fp-auto-height&quot;&gt;这里写版权&lt;/div&gt;&lt;/div&gt;如上，js代码就不说了，只要你能跑起来，就没有问题。这里只需要给头部和底部增加一个fp-auto-height 的 class ，然后自己可以加点class写样式。没有生效吗？嘿嘿，那是因为你只引用了js，而没有引用css造成的，只要引用下面的css即可。https://github.com/alvarotrigo/fullPage.js/blob/master/dist/jquery.fullpage.css其实关键代码只是下面的而已1234567891011.fp-auto-height.fp-section,.fp-auto-height .fp-slide,.fp-auto-height .fp-tableCell&#123; height: auto !important;&#125;.fp-responsive .fp-auto-height-responsive.fp-section,.fp-responsive .fp-auto-height-responsive .fp-slide,.fp-responsive .fp-auto-height-responsive .fp-tableCell &#123; height: auto !important;&#125;其他参数配置见官网对于多行text-overflow:ellipsis 溢出显示省略号的解决办法（尽量兼容所有浏览器）1、css解决12345678910111213141516@mixin ellipsis($line:1)&#123; word-break: break-all; @if $line == 1&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125;@else&#123; text-overflow:clip; display: -webkit-box; overflow: hidden; word-wrap: break-word; white-space: normal !important; -webkit-line-clamp:$line; -webkit-box-orient: vertical; &#125;&#125;2、js解决12345678910111213141516171819202122//截取的函数 双字节字符长度为2 ASCLL字符长度为1function cutStr(str,cutLen)&#123; var returnStr = &apos;&apos;, //返回的字符串 reCN = /[^\\x00-\\xff]/, //双字节字符 strCNLen = str.replace(/[^\\x00-\\xff]/g,&apos;**&apos;).length; if(cutLen&gt;=strCNLen)&#123; return str; &#125; for(var i=0,len=0;len&lt;cutLen;i++)&#123; returnStr += str.charAt(i); if(reCN.test(str.charAt(i)))&#123; len+=2; &#125;else&#123; len++; &#125; &#125; return returnStr;&#125;$(function ()&#123; var str = $(this).text(); $(this).text(cutStr(str,34)+&apos;...&apos;); &#125;);3、哈哈哈哈，后台解决麻烦以下后端小伙伴帮忙处理以下mac中隐藏文件的现实与关闭12defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder //显示mac中隐藏文件defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder //关闭mac中隐藏文件后续继续整理","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://cansolve.cn/tags/其他/"}]},{"title":"圣诞节🎄，刷刷面试题可能更适合我","slug":"daily12","date":"2018-12-24T13:06:28.000Z","updated":"2019-01-29T02:04:59.967Z","comments":true,"path":"2018/12/24/daily12/","link":"","permalink":"http://cansolve.cn/2018/12/24/daily12/","excerpt":"","text":"知道什么是事件委托吗？个人感觉这篇文章写的超级好，我就不班门弄斧了window的onload事件和domcontentloaded谁先谁后？一般情况下，DOMContentLoaded事件要在window.onload之前执行，当DOM树构建完成的时候就会执行DOMContentLoaded事件，而window.onload是在页面载入完成的时候，才执行，这其中包括图片等元素。大多数时候我们只是想在DOM树构建完成后，绑定事件到元素，我们并不需要图片元素，加上有时候加载外域图片的速度非常缓慢。你之前遇到过跨域问题吗？是怎么解决的。目前我知道的可以解决的方法有下面几种：jsonp、后端java或者php修改、nginx反向代理、postMessage。。。，应该还有，只是我很少用但是比较常用的是下面两种使用JSONP，其实用的也不多，因为感觉会导致安全问题，或者效率下降（这两点仅是我的猜测）。猜测的理由：任何来源都能访问, 会不会存在乱七八糟的js注入？后端和前端需要都JSONP进行处理。（代码繁琐，而且是所有请求都要使用JSONP）。在后端添加跨域头为Access-Control-Allow-Origin添加 *如果前端域名比较多，需要添加很多域名，为Access-Control-Allow-Origin添加目标域名 (Origin 请求头) 而不 是写死的域名或*typeof和instanceof的区别typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。它返回值是一个字符串，该字符串说明运算数的类型。（typeof 运算符返回一个用来表示表达式的数据类型的字符串。 ）typeof其实就是判断参数是什么类型的实例，就一个参数typeof 一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 语法：object instanceof constructor 参数：object（要检测的对象.）constructor（某个构造函数） 描述：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。12345678910111213function Person (name) &#123; this.name = name;&#125;function Student () &#123; &#125;Student.prototype = Person.prototype;Student.prototype.constructor = Student;let s = new Student(&apos;Tom&apos;);console.log(s instanceof Person); // 返回 true下面代码输出什么？123456for(var i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 0)&#125;// 10个10若要输出从0到9，怎么办？答案:将var改为let，或者使用闭包。12345678// 使用闭包for(var i = 0; i &lt; 10; i++) &#123; (function (i) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 0); &#125;)(i);&#125;for of 和 for in 的区别for in一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。不建议使用for in 遍历数组，因为输出的顺序是不固定的。如果迭代的对象的变量值是null或者undefined, for in不执行循环体，建议在使用for in循环之前，先检查该对象的值是不是null或者undefinedfor offor…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句上面是官方解释，我理解的最明显的区别，遍历下面数组for in是ES5标准，遍历key.for of是ES6标准，遍历value.12345678910var a=[1,2,3]for(let i in a)&#123; console.log(i); //0 1 2 这里的i输出的是下标 console.log(a[i]); //1 2 3 &#125; for(let i of a)&#123; console.log(i); //1 2 3 这里的i输出的是对应的值&#125;使用过flex布局吗？flex-grow和flex-shrink属性有什么用？flex-grow用来“瓜分”父项的“剩余空间”。容器的宽度为400px, 子项1的占用的基础空间(flex-basis)为50px，子项2占用的基础空间是70px，子项3占用基础空间是100px，剩余空间为 400-50-70-100 = 180px。 其中子项1的flex-grow: 0(未设置默认为0)， 子项2flex-grow: 2，子项3flex-grow: 1，剩余空间分成3份，子项2占2份(120px)，子项3占1份(60px)。所以 子项1真实的占用空间为: 50+0 = 50px， 子项2真实的占用空间为: 70+120 = 190px， 子项3真实的占用空间为: 100+60 = 160px。flex-shrink用来“吸收”超出的空间容器的宽度为400px, 子项1的占用的基准空间(flex-basis)为250px，子项2占用的基准空间是150px，子项3占用基准空间是100px，总基准空间为 250+150+100=500px。容器放不下，多出来的空间需要被每个子项根据自己设置的flex-shrink 进行吸收。 子项1的flex-shrink: 1(未设置默认为1)， 子项2 flex-shrink: 2，子项3 flex-shrink: 2。子项1需要吸收的的空间为 (250*1)/(250*1+150*2+100*2) * 100 = 33.33px，子项1真实的空间为 250-33.33 = 216.67px。同理子项2吸收的空间为(150*2)/(250*1+150*2+100*2) * 100=40px，子项2真实空间为 150-40 = 110px。子项3吸收的空间为(100*2)/(250*1+150*2+100*2) * 100 = 26.67px，真实的空间为100-26.67=73.33px。从输入URL到页面加载发生了什么？这里涉及很多的东西，这里只是简单的写一下大概的答案；1、浏览器的地址栏输入URL并按下回车。2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。4、根据IP建立TCP连接（三次握手）。5、HTTP发起请求。6、服务器处理请求，浏览器接收HTTP响应。7、渲染页面，构建DOM树。8、关闭TCP连接（四次挥手）。你知道哪些状态码？1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？贴个链接，比我解释的详细补充于2018-12-28什么是圣杯布局？官方解释：圣杯布局是为了讨论「三栏液态布局」的实现，最早的完美实现是由 Matthew Levine 在 2006 年写的一篇文章 《In Search of the Holy Grail》 ，它主要讲述了网页中关于最佳圣杯的实现方法。它有以下几点要求：上部(header)和下部(footer)各自占领屏幕所有宽度。上下部之间的部分(container)是一个三栏布局。三栏布局两侧宽度不变，中间部分自动填充整个区域。中间部分的高度是三栏中最高的区域的高度。实现方法1：浮动1234567891011121314151617181920212223&lt;div class=&quot;header&quot;&gt; &lt;h4&gt;header&lt;/h4&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;h4&gt;middle&lt;/h4&gt; &lt;p&gt;middle-content&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt; &lt;h4&gt;left&lt;/h4&gt; &lt;p&gt;left-content&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;h4&gt;right&lt;/h4&gt; &lt;p&gt;right-content&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; &lt;h4&gt;footer&lt;/h4&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334.header, .footer &#123; border: 1px solid #333; background: #ccc; text-align: center;&#125;.footer &#123; clear: both;&#125;.container &#123; padding:0 220px 0 200px; overflow: hidden;&#125;.left, .middle, .right &#123; position: relative; float: left; min-height: 130px;&#125;.middle &#123; width: 100%; background: blue;&#125;.left &#123; margin-left: -100%; left: -200px; width: 200px; background: red;&#125;.right &#123; margin-left: -220px; right: -220px; width: 220px; background: green;&#125;解析一下思路：在html中，先定义好header和footer的样式，使之横向撑满。在container中的三列设为浮动和相对定位(后面会用到)，middle要放在最前面，footer清除浮动。三列的左右两列分别定宽200px和220px，中间部分middle设置100%撑满这样因为浮动的关系，middle会占据整个container，左右两块区域被挤下去了接下来设置left的margin-left:-100%;，让left回到上一行最左侧但这会把middle给遮住了，所以这时给外层的container设置padding:0 220px 0 200px;，给left空出位置这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过left:-200px;把left拉回最左侧同样的，对于right区域，设置margin-right:-220px;把right拉回第一行这时右侧空出了220px的空间，所以最后设置 `right:-220px;##把right区域拉到最右侧就行了。实现方法2：flex弹性盒子这个我就不贴代码了， header和footer同上面一样，横向撑满。footer不用再清浮动了container中的left、middle、right依次排布即可，不用特意将middle放置到最前面给container设置弹性布局 display:flex;left和right区域定宽，middle设置 flex:1; 即可后续继续整理","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"js","slug":"js","permalink":"http://cansolve.cn/tags/js/"}]},{"title":"2019年React学习路线图","slug":"daily10","date":"2018-12-20T11:05:40.000Z","updated":"2018-12-24T04:22:46.515Z","comments":true,"path":"2018/12/20/daily10/","link":"","permalink":"http://cansolve.cn/2018/12/20/daily10/","excerpt":"","text":"作者｜javinpaul译者｜无明转发自 | 前端之巅公众号之前我们已经介绍了 2019 年 Vue 学习路线图，而 React 作为当前应用最广泛的前端框架，在 Facebook 的支持下，近年来实现了飞越式的发展，我们将在下文中介绍 2019 年 React 学习路线图，希望给想学 React 的开发者一些借鉴。下图是2018 年的 React 路线图，它非常全面，2018 年剩下的时间可能不够你学会所有这些，但不要担心，所有的技术在 2019 年仍然有效。图片来源：https://github.com/adam-golab/react-developer-roadmap/blob/master/roadmap.png1、基础知识不管你要学习哪个 Web 开发框架或库，都必须掌握基础知识，如 HTML、CSS 和 JavaScript，这三个是 Web 开发的三大支柱。HTMLHTML 是 Web 开发人员最重要的技能之一，因为它为网页提供了基本结构。CSSCSS 用于设置网页样式，让网页看起来更好看。JavaScriptJavaScript 让网页具备交互性。React 是基于 JavaScript 的，因此在学习 React 之前，你应该先了解 JavaScript。2、通用的开发技能无论你是前端开发人员还是后端开发人员，甚至是全栈工程师，都必须了解一些能够让你在编程世界中生存下来的通用开发技能。学习 GIT你必须在 2018 年完全了解 Git。尝试在 GitHub 上创建一些存储库，与其他人共享你的代码，并学习如何在你喜欢的 IDE 中克隆 Github 上的代码。了解 HTTP(S) 协议如果你想成为一名 Web 开发人员，那么了解 HTTP 绝对是有必要的。我不是要你去阅读 HTTP(S) 规范，但你至少应该熟悉常见的 HTTP 请求方法，如 GET、POST、PUT、PATCH、DELETE、OPTIONS 以及 HTTP/HTTPS 的工作原理。学习终端虽然前端开发人员学习 Linux 或终端并不是强制性的，但我强烈建议你熟悉以下终端，了解如何配置你的 shell（bash、zsh、csh）等。算法和数据结构好吧，这又是一个通用编程技能，成为 React 开发者不一定需要了解这些，但要成为真正的程序员，这是必备技能。学习设计模式就像算法和数据结构一样，成为 React 开发者并不一定要学习设计模式，但学好设计模式会让你变得更好。了解设计模式将帮你找到能够经受住时间考验的解决方案。3、学习 React你必须学好 React 才能成为一名 React 开发者。学习 React 最好的资源是它的官方网站，但作为初学者，它对你来说可能有点难。学习构建工具如果你想成为一名专业的 React 开发者，那么你应该花一些时间熟悉一下你将作为 Web 开发者需要使用的工具，比如构建工具、单元测试工具、调试工具等。以下是路线图中列出的构建工具：包管理器：npmyarnpnpm任务执行器npm 脚本gulpWebPackRollupParcel顺便说一句，并非要学习所有这些工具，对于初学者来说，学习 npm 和 Webpack 应该足够了。在你对 Web 开发和 React 生态系统有了更多的了解后，你就可以学习其他工具。样式如果你的目标是成为 React 开发者，了解一些样式相关的知识只会有益无害。路线图中提到了很多 CSS 相关的东西，比如 CSS 预处理器、CSS 框架、CSS 架构和 JS 中的 CSS。我建议你至少学习一下 Bootstrap，这是你经常会用到的 CSS 框架。如果你想进一步学习 bootstrap，也可以学习 Materialise 或 Material UI。状态管理这是 React 开发者应该关注的另一个重要领域。路线图中提到了以下一些需要掌握的概念和框架：组件 State/ContextAPIRedux异步操作（副作用）Redux ThunkRedux Better PromiseRedux SagaRedux ObservableHelpersRematchReselectData persistenceRedux PersistRedux PhoenixRedux FormMobX如果东西太多，我建议你只关注 Redux。Type Checker由于 JavaScript 不是一种强类型语言，因此编译器不会捕获那些与类型相关的错误。随着应用程序的增长，你可以通过类型检查捕获大量错误，尤其是如果你可以使用 Flow 或 TypeScript 等 JavaScript 扩展对整个应用程序进行类型检查。React 也提供了一些内置的类型检查功能，可以用它们帮你尽早发现 bug。由于 Angular 也使用了 TypeScript，我认为可以同时学习 JavaScript 和 TypeScript。Form Helper除了 Type Checker 之外，还可以学习像 Redux Form 这样的 Form Helper，它提供了在 Redux 中管理表单状态的最佳方法。除了 Redux Form 之外，还有 Formik、Formsy 和 Final。路由组件是 React 声明性编程模型的核心，而路由组件是应用程序的重要组成部分。React Router 提供了一组导航组件，这些组件可以通过声明的方式与你的应用程序组合在一起。除了 React Router 之外，你还可以看看 Router 5 和 Redux-First Router。API 客户端在今天的世界中，你很少会构建独立的 GUI，相反，你将有更多机会使用 REST 和 GraphQL 等 API 构建与其他应用程序发生交互的东西。值得庆幸的是，React 开发者可以使用很多 API 客户端：RESTFetchSuperAgentaxiosGraphQLApolloRelayurqlApollo 客户端是我的最爱，它提供了一种使用 GraphQL 构建客户端应用程序的简便方法。Apollo 可以帮你快速构建使用 GraphQL 获取数据的 UI，并可以与任意 JavaScript 前端一起使用。辅助库这些库可以让你的工作变得更轻松。React 开发人员可以使用很多辅助库，如下所示：LodashMomentclassnamesNumeralRxJSRamda这些不一定都要学，路线图中的 Lodash、Moment 和 Classnames 是用黄色标注的，所以应该先从它们开始学习。测试测试是 React 开发者的一项重要技能，但经常被忽视，如果你想在竞争中保持领先，就要学习一些用于测试的库。这些库可用于单元测试、集成测试和端到端测试。以下是路线图中提到的库：单元测试JestEnzymeSinonMochaChaiAVATape端到端测试Selenium, WebdriverCypressPuppeteerCucumber.jsNightwatch.js集成测试Karma你可以学习你想学习的库，但建议一定要学习 Jest 和 Enzyme。国际化这是前端开发的另一个重要主题。你可能需要支持日本、中国、西班牙和其他欧洲国家的本地 GUI 版本。路线图中建议你学习以下技术，它们都很好理解：React IntlReact i18next这两个库都提供了 React 组件和 API 来格式化日期、数字和字符串，包括复数和处理翻译。服务器端渲染你可能会想，服务器端渲染和客户端渲染之间有什么区别。在使用客户端渲染时，你的浏览器会下载一个最小的 HTML 页面，然后通过 JavaScript 并将内容填充到页面中。在使用服务器端渲染时，React 组件是在服务器上进行渲染的，将输出的 HTML 内容传到客户端或浏览器。路线图推荐了以下的服务器端渲染：Next.jsAfter.jsRogue不过我建议学习 Next.js 应该足够了。静态站点生成器Gatsby.js 是一个现代静态站点生成器。你可以使用 Gatsby 创建个性化的登录网站体验。它将你的数据与 JavaScript 相结合，并创建格式良好的 HTML 内容。后端框架集成React on Rails 将 Rails 与 Facebook 的 React 前端框架（服务器渲染）集成在一起。它提供了服务器渲染，通常用于 SEO 爬虫索引和 UX。4、移动端React Native 正迅速成为使用 JavaScript 开发具有原生外观的移动应用程序的标准方法。路线图中建议你学习以下库：React NativeCordova/PhoneGapFlutter—————–本人添加但我认为只要学习 React Native 就足够了。这里补充一句我个人想法，现在应该要关注一下Flutter的发展了—————–本人添加5、桌面端还有一些基于 React 的框架可用于构建像 React Native Windows 这样的桌面 GUI，让你可以使用 React 构建原生 UWP 和 WPF 应用程序。路线图建议使用以下几个库：Proton NativeElectronReact Native Windows它们都是进阶的内容，如果你已经掌握了 React，可以看一下它们。6、虚拟现实如果你对构建基于虚拟现实的应用程序感兴趣，还可以了解以下像 React 360 这样的框架，让你可以通过 React 开发 VR 体验。如果你对这个领域感兴趣，可以进一步了解 React 360。英文原文：https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.cn/categories/分享/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cansolve.cn/tags/react/"}]},{"title":"es6中的promise解读","slug":"daily8","date":"2018-11-23T11:45:40.000Z","updated":"2018-12-19T09:52:38.175Z","comments":true,"path":"2018/11/23/daily8/","link":"","permalink":"http://cansolve.cn/2018/11/23/daily8/","excerpt":"","text":"作者：离秋链接：https://juejin.im/post/5bed21156fb9a04a0c2e025d简单的说它是一个异步流程的控制手段。是一个代表了异步操作最终完成或者失败的对象。promise的优点promise解决了回调地狱的问题promise可以支持多个并发的请求promise的错误传播机制可以统一的处理错误信息回调地狱问题在传统的ajax调用过程中，下面以jquery.ajax为例。如果需求中要多次进行ajax交互，并且上一次的返回结果还要被下一次的ajax使用，代码基本上会变成：123456789101112131415$.ajax(&#123; type: &quot;POST&quot;, url: &quot;some.php&quot;, data: &quot;name=John&amp;location=Boston&quot;, success: function(msg)&#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;some.php&quot;, data: msg, success: function(msg2)&#123; ...//多次调用 &#125; &#125;); &#125;&#125;);现在还只是两次调用关系，如果是多次调用将会引发下面的问题多次调用不利于代码的管理于维护发生错误时不能及时准备的定位错误位置只要又一次不成功就不能进行下面的逻辑，不方便进行错误处理。promise的链式调用就很好的解决了这个问题Promise的三种状态Pending Promise对象实例创建时候的初始状态resolve 可以理解为成功的状态Reject 可以理解为失败的状态promise 中的状态只能是从等待状态转换到成功状态或者失败状态，且状态转变之后不可逆。一个简单的promise12345let p = new Promise((resolve, reject) =&gt; &#123; console.log(1)&#125;);console.log(2)//1 2promise里面只接受一个参数，叫做执行器函数，这个函数会同步执行。也就是说上面代码中的箭头函数被同步执行，得到的结果也就是1和2promise中的then每一个promise的实例上都有一个then方法，这个方法上有两个参数，一个是成功的回调，一个是失败的回调。而取决于成功或者失败的是promise的执行器函数中执行的是成功还是失败。12345678910111213let p = new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve();//调用resolve会走到then的成功回调 //reject();//调用resolve会走到then的失败回调&#125;);p.then( () =&gt; &#123; console.log(&apos;成功&apos;) &#125; , () =&gt; &#123; console.log(&apos;失败&apos;) &#125;) //1 成功如果既不调用resolve也不调用reject，promise则一直处于等待状态，也就不会走到then方法。1234567891011let p = new Promise((resolve, reject) =&gt; &#123; console.log(1);&#125;);p.then( () =&gt; &#123; console.log(&apos;成功&apos;) &#125; , () =&gt; &#123; console.log(&apos;失败&apos;) &#125;) //1如果你既调用resolve也调用reject，那么谁在前面执行就走谁的对应回调函数12345678910111213let p = new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve()//先调用成功 reject()&#125;);p.then( () =&gt; &#123; console.log(&apos;成功&apos;) &#125; , () =&gt; &#123; console.log(&apos;失败&apos;) &#125;) //1 成功12345678910111213let p = new Promise((resolve, reject) =&gt; &#123; console.log(1); reject()//先调用失败 resolve()&#125;);p.then( () =&gt; &#123; console.log(&apos;成功&apos;) &#125; , () =&gt; &#123; console.log(&apos;失败&apos;) &#125;) //1 失败如果代码出错则会直接走reject的回调123456789101112let p = new Promise((resolve, reject) =&gt; &#123; console.log(1); throw new Error(&apos;出错了~&apos;)&#125;);p.then( () =&gt; &#123; console.log(&apos;成功&apos;) &#125; , () =&gt; &#123; console.log(&apos;失败&apos;) &#125;) //1 失败一个promise的实例可以then多次123456789let p = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;成功了&apos;);&#125;);p.then((data) =&gt; &#123; console.log(data)//成功了&#125;);p.then((data) =&gt; &#123; console.log(data)//成功了&#125;)利用promise解决回调地狱能够规避异步操作中回调地狱的问题，其本质取决于promise的链式调用。 假设需求如下，a.txt文件的内容为b.txt,b.txt文件的内容是一段描述文字，现在要求用a.txt的得到最终的描述文字，代码如下：12345678910111213141516171819let fs = require(&apos;fs&apos;);//首先将异步方法封装在一个promise中，异步结果成功调用resolve方法，失败调用reject方法。function read(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(url, &apos;utf8&apos;, function (err, data) &#123; if (err) reject(); resolve(data); &#125;) &#125;)&#125;//因为read方法返回的是一个promise，所以可以使用promise的then方法read(&apos;a.txt&apos;).then((data) =&gt; &#123;//第一次异步成功后拿到结果继续返回一个promise可以实现链式调用。 console.log(data);//b.txtreturn read(data);&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;//最后两次的结果分别对应两次异步的返回内容 console.log(data)//描述文字&#125;, (err) =&gt; &#123; &#125;)总结：如果一个promise的then方法中还返回另一个promise，那么这个promise的成功状态会走到外层promise的下一次then方法的成功，如果失败，返回外层promise下一次then的失败。promise的链式调用如果then中返回的是一个普通值，就会走到下一次then的成功回调。12345read().then((data) =&gt; &#123;return 111&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;console.log(data)//111&#125;, (err) =&gt; &#123; &#125;)如果then中返回的是一个错误，就会走到下一次then的失败回调。1234567read().then((data) =&gt; &#123;throw new Error(&apos;出错了~&apos;)&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;console.log(data)&#125;, (err) =&gt; &#123;console.log(err)//出错了~&#125;)如果then中什么也不返回，就会走到下一次then的成功回调，得到的值为undefined。123456read().then((data) =&gt; &#123;cons.log(111)&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;console.log(data)//undefined&#125;, (err) =&gt; &#123;&#125;)如果想统一处理错误内容，可以使用catch。12345read().then((data) =&gt; &#123;throw new Error(&apos;出错了~&apos;)&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;).catch((err)=&gt;&#123; //错误处理&#125;)统一处理错误后，还可以使用then。12345read().then((data) =&gt; &#123;throw new Error(&apos;出错了~&apos;)&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;).catch((err)=&gt;&#123; //错误处理&#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;)Promise.all()all方法可以处理多个请求并发的问题。参数是一个数组。all方法调用后会返回一个新的promise。1234567891011121314let fs = require(&apos;fs&apos;);function read(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(url, &apos;utf8&apos;, function (err, data) &#123; if (err) reject(); resolve(data); &#125;) &#125;)&#125;Promise.all([read(&apos;1.txt&apos;), read(&apos;2.txt&apos;)]).then((data) =&gt; &#123; console.log(data)//[ &apos;文本1内容&apos;, &apos;文本2内容&apos; ]&#125;, (err) =&gt; &#123; console.log(err);&#125;)在all方法中一个失败了就全部失败，所以都成功了才会走成功回调。12345Promise.all([read(&apos;1.txt&apos;), read(&apos;3.txt&apos;)]).then((data) =&gt; &#123; console.log(data)&#125;, (err) =&gt; &#123; console.log(&apos;失败了&apos;);//失败了&#125;)Promise.race()多个请求中，谁的返回数据最快，结果就是谁12345Promise.race([read(&apos;1.txt&apos;), read(&apos;2.txt&apos;)]).then((data) =&gt; &#123; console.log(data)////文本2内容&#125;, (err) =&gt; &#123; console.log(&apos;失败了&apos;);&#125;)Promise.resolve()返回一个成功的Promise123Promise.resolve(&apos;123&apos;).then((data) =&gt; &#123; console.log(data)//123&#125;)Promise.reject()返回一个失败的Promise123Promise.reject(&apos;123&apos;).then((data) =&gt; &#123; console.log(&apos;err&apos;, data)//err 123&#125;)","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.cn/categories/分享/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://cansolve.cn/tags/es6/"}]},{"title":"重新理解一遍回流(reflow)与重绘(repaint)","slug":"daily15","date":"2018-11-04T10:02:04.000Z","updated":"2019-01-04T10:37:56.420Z","comments":true,"path":"2018/11/04/daily15/","link":"","permalink":"http://cansolve.cn/2018/11/04/daily15/","excerpt":"","text":"一次页面重构过程中遇到的问题，回流和重绘，面试题中经常有，可是我之前一直不是很清楚这两步具体做了什么事情。今天刚好事情做完又看到这个问题，就去查了查资料，理解一下，写了这篇文章加深一下印象，有什么写的不好的希望大家多指正。浏览器的渲染过程这里得先从浏览器的渲染过程讲起，此处你也可以跳过，因为得先了解渲染过程才能知道回流和重排在哪个阶段执行。从这个图就可以看出浏览器渲染过程；解析html和css，生成DOM树以及cssom；html和css结合起来生成Render Tree；回流： 根据生成的渲染树，进行回流(Layout)，得到可见节点的几何信息（位置，大小）重排： 根据回流得到的信息结合渲染树，进行渲染展示#生成渲染树为了构建渲染树，浏览器主要完成了以下工作：从DOM树的根节点开始遍历每个可见节点。对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。根据每个可见节点以及其对应的样式，组合生成渲染树。这里说到了要遍历可见的节点，什么节点是不可见的。不可见的节点包括：一些不会渲染输出的节点，比如script、meta、link等。一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。注意：渲染树只包含可见的节点回流前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，当render树中的一部分或者全部因为大小边距等问题发生改变而需要重建的过程叫做回流。为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：123456789101112&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;Critial Path: Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=&quot;width: 50%&quot;&gt; &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）重绘最终，我们通过构造渲染树和回流阶段，有了DOM结构的节点，有了节点的位置样式，接下来就开始渲染到页面上，当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘现在知道了浏览器的渲染过程，我们就来探讨下，何时会发生回流重绘。何时发生回流重绘我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，所以可以理解当页面布局和几何信息发生变化的时候，肯定会发生回流。比如以下情况：添加或删除可见的DOM元素元素的位置、尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。页面一开始渲染的时候（这肯定避免不了）浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）12345678var s = document.body.style; s.padding = &quot;2px&quot;; // 回流+重绘 s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘 s.color = &quot;blue&quot;; // 再一次重绘 s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘 s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘 // 添加node，再一次 回流+重绘 document.body.appendChild(document.createTextNode(&apos;abc!&apos;));注意：回流一定会触发重绘，而重绘不一定会回流为什么：上面说了定义很明显—如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘，布局没有变化就不会发生回流；触发回流的css 属性有这些:而触发重绘的有这些:说到这里大家都知道回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。浏览器的优化机制现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightgetComputedStyle()getBoundingClientRect具体可以访问这个网站：https://gist.github.com/paulirish/5d52fb081b3570c81e3a以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。最小化重绘和重排由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。总结了以下几点：1：用transform 代替 top，left ，margin-top， margin-left… 这些位移属性2：用opacity 代替 visibility，但是要同时有translate3d 或 translateZ 这些可以创建的图层的属性存在才可以阻止回流但是第二点经过我的实验，发现如果不加 transform: translateZ(0) 配合opacity的话还是会产生回流的，而只用visibility 就只会产生重绘不会回流而 opacity 加上 transform: translateZ/3d 这个属性之后便不会发生回流和重绘了3：不要直接使用js操作dom元素的样式，选择用一个class 代替之。4：如果确实需要用 js 对 dom 设置多条样式那么可以将这个dom 先隐藏，然后再对其设置5：不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight… 这些。浏览器有一个回流的缓冲机制，即多个回流会保存在一个栈里面，当这个栈满了浏览器便会一次性触发所有样式的更改且刷新这个栈。但是如果你多次获取这些元素的实际样式，浏览器为了给你一个准确的答案便会不停刷新这个缓冲栈，导致页面回流增加。所以为了避免这个问题，应该用一个变量保存在循环体外。123456789101112131415161718clientWidth在循环体内：function startTest1() &#123; const box1 = document.querySelector(&apos;#box1&apos;); const p = document.querySelectorAll(&apos;p&apos;); for (let i = 0; i &lt; p.length; i++) &#123; p[i].style.width = box1.clientWidth + &apos;px&apos;; &#125; &#125; clientWidth在循环体外：function startTest2() &#123; const box2 = document.querySelector(&apos;#box2&apos;); const p = document.querySelectorAll(&apos;p&apos;); const width = box2.clientWidth; for (let i = 0; i &lt; p.length; i++) &#123; p[i].style.width = width + &apos;px&apos;; &#125; &#125;6：不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局7：动画的速度按照业务按需决定8：对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用video 标签9：必要时可以开启 GPU 加速，但是不能滥用使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。css3硬件加速的坑如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://cansolve.cn/tags/其他/"}]},{"title":"viewport-fit解决iPhone X、XS、XS Max、XR刘海屏问题","slug":"daily2","date":"2018-10-10T03:28:29.000Z","updated":"2018-12-14T07:26:24.000Z","comments":true,"path":"2018/10/10/daily2/","link":"","permalink":"http://cansolve.cn/2018/10/10/daily2/","excerpt":"","text":"一次活动页面发现的iPhone X、XS、XS Max、XR刘海屏问题起因：游戏内嵌内嵌H5页面，提供的webview容器是全屏的，所以H5页面要处理以上设备的刘海问题【烦】。尺寸了解我这里就不写了，尺寸问题我就不写了，顶楼电梯iPhone X 配备一个覆盖整个手机的全面屏,顶部的“刘海”突出来使得网站被限制在一个“安全区域”,在两侧边缘会出现白条儿。移除这个白条儿也不难,给 body 设置一个 background-color 就可以搞定。但是我们内嵌的游戏页面背景色有时候不好设置背景色为纯色，另一种方法就是添加 viewport-fit=cover meta 标签,将整个网站扩展到整个屏幕1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;iPhone XS等手机还未发布之前，我们也是跟着学做已经做一些兼容来搞定iPhoneX。这里只是横屏代码，竖屏同理；1var isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;这里我们判断如果是iPhone X，把顶部增加高度30px的容器垫高，避开刘海头区域，各种方式都可以padding-left、absolute、margin-left。。。你能想到的方法都可以，这样标题正好避开刘海头。因为自己当时还没有用iPhone X，只知道iPhone X有刘海头，不知道其他细节问题。又到一年一度的9月份，苹果发布了3X机系列，有同事在Mac下的iPhone模拟器访问，发现这个页面iPhone XS Max下有问题。看了一下上面文章发现尺寸不一样，当初只判断了iPhone X加垫高，其他几个机型都未判断，所以就很自然的写了新机型，加上判断：123456// iPhone X、iPhone XSvar isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;// iPhone XS Maxvar isIPhoneXSMax = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;// iPhone XRvar isIPhoneXR = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 2 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;原来代码是if(isIPhoneX)垫高，现在改成if(isIPhoneX || isIPhoneXSMax || isIPhoneXR)垫高。这里有个坑，官方提供的安全区域代码constant(safe-area-inset-top) env(safe-area-inset-top)，使用后都在刘海头下面，如图（黑灰色区域状态栏）：当初没有用安全区域代码，一方面是因为页面有悬浮容器，会悬浮到安全区域外部，兼容页面正文麻烦，另一方面就是正文内容靠下，离刘海头有一段距离，感觉太丑干脆不用。总结：依旧不用安全区域代码，如果要做刘海头，if(isIPhoneX || isIPhoneXSMax || isIPhoneXR) 垫高44px。备注：iPhone X、iPhone XS、iPhone XS Max刘海头高度30px，iPhone XR刘海头高度33px。本文提到的30px、33px、44px，均为initial-scale=1下，px是在通用属性下，用rem写页面的请自行转换。设计稿像素应该都需要乘以2倍或3倍。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.cn/tags/移动端/"}]},{"title":"Git 使用经验分享","slug":"daily9","date":"2018-10-07T01:05:40.000Z","updated":"2018-12-20T08:19:53.780Z","comments":true,"path":"2018/10/07/daily9/","link":"","permalink":"http://cansolve.cn/2018/10/07/daily9/","excerpt":"","text":"版本控制Git 是分布式版本控制.每一台用户终端都可以充当中央仓库的角色,镜像整个仓库。 Git 主要对提交的全部文件制作一个快照并保存这个快照的索引，所以高效。Git开发流程Git开发过程中牵涉到：工作区、暂存区、仓库（本地仓库和远程仓库）Git 本地仓库常用操作添加与删除暂存区操作12345678git add 将文件加入到暂存区域git add . 添加当前目录的所有文件到暂存区git add [dir] 添加指定文件或文件夹到暂存区git add [file1] [file2] ... 添加指定文件到暂存区git add ./*.java 支持正则表达式git rm 删除文件.git rm [file1] [file2] 删除工作区文件，并且将这次删除放入暂存区git rm --cached [file] 删除暂存索引, 保留文件, 即恢复成untracked状态，并且将这次删除放入暂存区（已跟踪）提交本地库操作123git commit 将暂存区域的文件提交到版本库git commit --amend -m [message] 使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit -a 则将已跟踪但未暂存的文件和已跟踪且已暂存的文件一起提交本地分支操作1234git checkout [branch] 切换分支git checkout -b [branch] 创建并且切换分支git checkout master file_name 放弃当前对文件file_name的修改，用本地库当前分支的文件进行替换git checkout commit_id file_name 取文件file_name的 在commit_id是的版本。分支合并操作12345git merge [branch] 合并指定分支到当前分支，并且提交版本库，把分支的commit log带到新分支git merge [branch] --squash 合并指定分支到当前分支，不移动HEAD，不提交。需要进行一次额外的 git commit 来.带来好处不会把分支的 commit 记录带到新分支来。git merge [master] [branch] 将[master]合并到[branch] 分支git reset --hard HEAD 可以用此来撤销合并，其实就是回滚合并前的状态git cherry-pick [commit] 选择一个commit，合并进当前分支，用在部分功能合并Git 远程仓库常用操作1.提交到远程库123git push origin mastergit push origin 当前分支与远程分支之间存在追踪关系（git clone，或手动建立 git branch --set-upstream master origin/next），则本地分支和远程分支都可以省略。git push 当前分支只有一个追踪分支，那么远程别名都可以省略2.取回远程仓库的变更但并不自动合并当前的工作分支（fetch）1git fetch origin master 取回远程 origin 的 master 分支变更该命令经常与 git checkout 搭配使用，用来获取远程仓库的分支3.获取更新 并且合并当前分支（pull）。12git pull (= git fetch + git merge) git pull 命令相当于 git fetch + git merge, 即从远程仓库中拉取所有你本地仓库中还没有的数据, 并自动合并到当前工作分支.开发中常用一. 获取远程分支，进入分支开发功能,开发完后合并主干，最后提交主版本到远程仓库1234567891011121314151617181920211 git remote show origin （查看远程分支情况） 2 git fetch origin new_branch (获取远程分支的变更到本地仓库) 3 git checkout new_branch （切换分支new_branch进行开发） 4 开发相关功能文件 5 git add file 6 git commit 7 git checkout master （切换到主干） 8 git merge new_branch (把new_branch合并到当前的所在分支) 9 git push origin master 10 git branch -d new_branch (删除分支) 11 git branch (查看当前分支情况，确认删除)二. 文件修改后想还原到上次提交的状态（不保留修改内容）123git checkout (文件未提交到暂存区用法)git checkout HEAD （如提交到暂存区执行该命令后，不保存暂存区）git reset --hard HEAD （如提交到暂存区执行该命令后，不保存暂存区）三. 撤销上一次提交本地仓库的文件1234567891 git log (查看提交版本信息) git reset 前一个SHA值（7位数）（撤销commit，会保留提交前的修改内容） 2 git reset --soft HEAD^1 退到commit前，保留stage（暂存区）和提交前修改内容 3 git reset --mixed HEAD^1 退到commit前，保留提交前修改内容（默认） 4 git reset --hard HEAD^1退到commit前且恢复到未修改时内容（内容退回到上次commit时的状态） 5 git reset SHA值 让单个文件退回到指定版本四. 回滚区别(reset与revert)共同点：都可用回滚不同点：reset 可回滚到之前某个提交（可能是批量回滚），删除被回滚的log，另外不可回滚到已 push 过的的提交，否则回滚后当前版本低于远程版本，被禁止提交。使用场景：对本地仓库中未push的提交的回滚revert 撤销一个提交的同时会创建一个新的提交可用于回滚被 push 过的提交。被回滚的版本git log不会被删除。使用场景：你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用 git revert，它帮你做了所有的事情。五. 当前文件与本地仓库文件比较区别123git diff 比较的是工作目录树与暂存区之间的区别git diff --staged 比较的是暂存区和版本库最后一个版本的区别。git diff HEAD 比较的是工作目录树（包括暂存的和未暂存的修改）与版本库最后一个版本的差别。六. 保持本地仓库与远程仓库分支同步的情况12345671 git remote show origin （显示本地与远程仓库所有分支情况）如远程分支删除后，本地还有，用 git branch -a 是看不出远程仓库分支已经被删除 2 git remote prune origin --dry-run （该命令显示本地无效分支） 3 git remote prune origin （同步本地与远程仓库变更（所有分支），执行后可用git branch -a查看） 4 git fetch origin [branch]七. Git 客户端工具可视化操作工具推荐使用：Sourcetree)","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"git","slug":"git","permalink":"http://cansolve.cn/tags/git/"}]},{"title":"JavaScript中的this","slug":"daily5","date":"2018-09-22T08:11:23.000Z","updated":"2018-12-20T02:54:25.567Z","comments":true,"path":"2018/09/22/daily5/","link":"","permalink":"http://cansolve.cn/2018/09/22/daily5/","excerpt":"","text":"原文链接：flaviocopes.com翻译：我可是兔子this在不同的地方被调用有不同的值。不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。this在严格模式下除了在声明的对象内被调用,this在严格模式下永远是undefined。注意我提到的是严格模式。如果不是在严格模式下 (在js的头部，你没有明确的添加&#39;use strict&#39;关键字 ), 那么你就处在非严格模式的状态下,this在这个环境下， 除了我下面提到的特殊案例外 ，this指代的是全局对象的值。在浏览器的上下文环境中，这个值就是window。在函数方法中的this方法就是以函数形式附属于一个对象。函数可以有不同的声明形式。下面就是其中的一种：1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;car.drive()//Driving a Ford Fiesta car!在这个例子中，使用了常规的函数声明的形式,this自动绑定为car这个对象。注意: 上面的函数声明是drive: function() {…这样声明的缩写12345678const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive: function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;和上面的例子一样的指代:1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;car.drive = function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)&#125;car.drive()//Driving a Ford Fiesta car!在同样的语境下，使用箭头函数来声明函数，this的指代是不一样的，它属于词法（静态）绑定:1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive: () =&gt; &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;car.drive()//Driving a undefined undefined car!使用箭头函数你不能在箭头函数中像其他正常的函数声明形式那样给函数绑定一个值来改变this的值。导致这个的主要原因是箭头函数的工作原理。this在箭头函数中是词法绑定的, 也就是说它的值仅取决于它在哪个对象下被定义。明确地传递一个对象来改变this的值JavaScript提供了一些方法来映射this所指代的对象，从而得到你想要的值。在函数声明的阶段，使用bind():1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;const drive = function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)&#125;.bind(car)drive()//Driving a Ford Fiesta car!你可以绑定一个已定义的对象来改变this的值:12345678910111213141516const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;const anotherCar = &#123; maker: &apos;Audi&apos;, model: &apos;A4&apos;&#125;car.drive.bind(anotherCar)()//Driving a Audi A4 car!使用call()或者apply(), 在函数调用阶段:1234567891011121314const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;const drive = function(kmh) &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car at $&#123;kmh&#125; km/h!)&#125;drive.call(car, 100)//Driving a Ford Fiesta car at 100 km/h!drive.apply(car, [100])//Driving a Ford Fiesta car at 100 km/h!第一个传递给call()或者apply()的参数是新的this所指代的值。 call() 和 apply()两个函数的差异在于第二个参数，apply() 接受的是一个数组来作为它的参数，而call() 函数接受的是一串参数列表。DOM事件处理函数的特殊案例在浏览器事件处理函数的时候,this指代的是HTML对象，像下面的这样：123document.querySelector(&apos;#button&apos;).addEventListener(&apos;click&apos;, function(e) &#123; console.log(this) //HTMLElement&#125;但你可以使用bind() 函数来改变this值：123456document.querySelector(&apos;#button&apos;).addEventListener( &apos;click&apos;, function(e) &#123; console.log(this) //Window if global, or your context &#125;.bind(this))","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.cn/categories/分享/"}],"tags":[{"name":"js","slug":"js","permalink":"http://cansolve.cn/tags/js/"}]},{"title":"移动端滚动事件overflow-y:scroll使用心得","slug":"daily4","date":"2018-09-18T07:45:43.000Z","updated":"2018-12-18T08:06:30.332Z","comments":true,"path":"2018/09/18/daily4/","link":"","permalink":"http://cansolve.cn/2018/09/18/daily4/","excerpt":"","text":"作者：夏大师https://www.cnblogs.com/xiahj/p/8036419.html1. -webkit-overflow-scrolling:touch是什么？MDN上是这样定义的：-webkit-overflow-scrolling属性控制元素在移动设备上是否使用滚动回弹效果.auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。在移动端上，在你用overflow-y:scorll属性的时候，你会发现滚动的效果很木，很慢，这时候可以使用-webkit-overflow-scrolling:touch这个属性，让滚动条产生滚动回弹的效果，就像ios原生的滚动条一样流畅。2. 解决safari布局抖动的例子想实现一个布局为header、main、bottom的布局，其中头部和底部通过fixed固定，中间部分通过滚动条滑动。如果目的是实现只要中间的内容超过屏幕高度时，中间内容会自动滚动的效果的话，main部分加上上下的padding，然后不需要自己添加任何滚动条属性，当超出高度时，body会自动产生滚动条。这样我们的目的其实是实现了的。但是在safari上，当超出高度，页面往下滑时，浏览器底部的工具栏会随着页面一起晃动（向下滚动时会拉起底部工具栏），造成了很不好的体验。所以我们想在中间的main部分加一个独立的滚动条。2.1 方案一在main上使用fixed定位，加上overflow-y属性。123456.main &#123; position: fixed; top: 50px; bottom: 50px; overflow-y: scroll;&#125;不过不推荐这个fixed方案，因为页面偶尔卡住不动，下面说到了这个问题。2.2 方案二中间的main不设定位，高度100%，再padding头部和尾部，其中头部和底部的定位设为absolute会比设为fixed体验更好（况且fix布局在移动端本来就有各种各样的问题，还是尽量避开:) ）。大致代码如下，仍是overflow-y和-webkit-overflow-scrolling，重点在于中间部分依照文本流布局。123456789html, body &#123; height: 100%;&#125;main &#123; padding: 50px 0; height: 100%; overflow-y: scroll; -webkit-overflow-scrolling: touch;&#125;3. 探究-webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug-webkit-overflow-scrolling:touch这个属性真的是各种坑，我研究这个属性已经大半年了，还没有发现能够在safari上完美使用无bug的例子。最常见的例子就是，在safari上，使用了-webkit-overflow-scrolling:touch之后，页面偶尔会卡住不动。在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。通过动态添加内容撑开容器，结果根本不能滑动的bug。在网上也看到了一些人在问这个问题，不过不多，国外倒是讨论的更多一点，描述如下。偶尔卡住的问题，解决方案网上众说纷纭，遇到了很多相同的说法，比如如果卡住不动的话，就加一个z-index，就能解决该问题的说法。在试了很多次之后，这种说法没有一次解决过这个问题。这个说法能够传播出来，可能是使用者当时在使用的时候遇到了-webkit-overflow-scrolling:touch点透或者层级的问题。所以该方案不具有适用性。所以这个东西真的让我很苦恼了很久，以致于那段时间所有的滚动条不是通过body自己滚动，就是使用iScroll这样的库，繁琐地让我几乎想要放弃移动web，拥抱hybrid，不过在stackoverflow潜水了很久之后，总结了以下几种解决方案：3.1 保证使用了该属性的元素上没有设置定位如果出现偶尔卡住不动的情况，那么在使用该属性的元素上不设置定位或者手动设置定位为static1position: static这样会解决部分因为定位(relative、fixed、absolute)导致的页面偶尔不能滚动的bug。但是滑动到顶部继续手指往下滑，或者到底部继续往上滑，还是会触发卡住的问题（其实是整个页面上下回弹），说他算bug，其实就是ios8以上的特性，如果滚动区域大一点，用户不会觉得这是bug，如果小了，用户会不知道发生了什么而卡住了。视频在这，有梯子的同学可以看一看https://www.youtube.com/watch?v=MkAVYbO_joo。3.2 如果添加动态内容页面不能滚动，让子元素height+1如果在-webkit-overflow-scrolling:touch属性的元素上，想通过动态添加内容来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。国内没有人讨论这个问题，国外倒是很多，例如下面的描述：收集了很多资料，用了之后，下面的方法真正的解决了我的问题，真是直呼神奇，方案如下图：图一：图二：方法就是在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。123main-inner &#123; min-height: calc(100% + 1px)&#125;你也可以直接加伪元素上：123main:after &#123; min-height: calc(100% + 1px)&#125;这个方案不得不说真的好用。。当然还有其他方案，不过要写js或者jq了，麻烦。3.3 为什么会有卡住不动的这个bug这个bug产生于ios8以上（不十分肯定，但在ios5~7上需要手动使用translateZ(0)打开硬件加速）Safari对于overflow-scrolling用了原生控件来实现。对于有-webkit-overflow-scrolling的网页，会创建一个UIScrollView，提供子layer给渲染模块使用。我想说作为一个苦逼的前端只能解决到这了。4. -webkit-overflow-scrolling:touch的其他坑除此之外，这个属性还有很多bug，包括且不限于以下几种：滚动中 scrollTop 属性不会变化手势可穿过其他元素触发元素滚动滚动时暂停其他 transition","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.cn/categories/分享/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.cn/tags/移动端/"}]},{"title":"基于react + bootstrap 的 react-admin","slug":"daily3","date":"2018-09-14T07:52:19.000Z","updated":"2018-12-18T09:16:49.973Z","comments":true,"path":"2018/09/14/daily3/","link":"","permalink":"http://cansolve.cn/2018/09/14/daily3/","excerpt":"","text":"前言此 react-admin 项目是基于 bootstrap-ace 框架之上，用 react 全家桶 + bootstrap 的进行再次开发的，项目已经开源，项目地址在 github 上。框架效果预览 http://www.pydyun.com/other/ace/index.htmlgithub地址 github1. 后台管理主要项目结构123456789101112131415161718192021222324demo //项目名 -- dist //预编译，自动构建之后会生成的文件，默认初始化是没有当前这个文件 -- asserts //静态资源目录，css,font,image -- public //html模板文件 -- webpack //webpack配置文件 -- webpack.base.config.js //公用 -- webpack.dev.config.js //开发环境 -- webpack.prod.config.js //生产环境 -- src //js编写文件 -- index.js // 初始化js -- module // 基础UI模块目录 -- tools // js方法工具库目录 -- action // action 目录 -- component // 对应的模块 目录 -- dispatch // dispatch 目录 -- reducers // reducers 目录 -- index.js // 前端渲染 -- router.js // 前端路由 -- store.js // store 文件 -- .babelr //babel的校验文件 -- .eslintrc //js编写校验配置文件 -- .gitignore //git过滤文件 -- package.json //node 安装包文件 -- README.md //readme 文件2. 本地必须要有node和git环境webpack 4bootstrap + acereact 16react-router 4redux 3babelpromiseasync + await3. 项目开始先在对应的git先创建git仓库，比如：XX管理后台 demo 项目，然后 git clone 到本来的开发环境，进入当前项目目录，代码如入：12git clone ssh://git@github.com:cansolve/react-manage.gitcd demo或者12cd demogit remote add origin ssh://git@github.com:cansolve/react-manage.git这时，通过git来添加前端开发初始化的工程目录，代码如下：12git remote add base ssh://git@github.com:cansolve/react-manage.gitgit pull base master --allow-unrelated-histories然后可以推送到开发项目上面去，代码如下：123git add .git commit -m &apos;前端项目初始化&apos;git push origin demo到此，你的 demo 项目前端搭建和初始化已完毕，接下来你就可以开始 前端开发 了4. 本地项目开始先安装编译第三方的依赖包1npm install123//如果开发之前本地没有对应的server服务器，也可以用node搭个server服务器，默认是8080端口:127.0.0.1:8080,如果有的话，直接跳过这一步npm install -g http-serverhttp-server -c-14.1 开发环境生产环境中开发监听对应的文件修改1npm run start4.2 生产环境压缩生产对应的线上文件，生产 html css image font js 文件1npm run build4.3 前端的升级和更新后续当前项目的前端库升级，bug修复，版本更新，直接可以通过命令来实现1git pull base master如有改动跟本地开发的导致冲突，请手动处理冲突文件，然后push到对应项目中去。5. 项目组建介绍5.1 表格组建说明：这里表格已经写成组建形式，只需要传入对应的title及data 后台获取数据 即可渲染成表格，对应的可以选择排序、勾选、包括给详情加a标签功能;5.2 分页组建说明：分页组建，点击传入对应页码，支持输入跳转;5.3 日历组建说明：日历时间选择组建，点击展示日期列表，选择传给后台为时间戳格式;5.4 下拉选择组建说明：点击出现下拉框，支持搜索功能5.4 下拉选择【多选】组建说明：点击出现下拉框，多选功能5.4 树组建说明：传入对应的数据即可渲染成树5.4 双向选择组建说明：两边数据可以互通选择，支持一键全部选择，两边数据都支持搜索功能；具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；5. 最后因为这是本人自己依据creat-react-app搭建的，跟公司项目目录还是有一定区别的，包括本人写代码的一些不好的地方还请多指正。大神请绕道，放小弟一条生路，谢谢啦！！本人公众号 码上关注 不定期分享一些前端知识，一起相互交流学习。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cansolve.cn/tags/react/"}]},{"title":"前端自动化部署jenkins","slug":"daily11","date":"2018-08-24T09:19:59.000Z","updated":"2018-12-24T10:24:03.553Z","comments":true,"path":"2018/08/24/daily11/","link":"","permalink":"http://cansolve.cn/2018/08/24/daily11/","excerpt":"","text":"一、jenkins工具的安装、卸载、启用注意：安装jenkins必须先安装java sdk，同时安装好brew工具（http://brew.sh/index_zh-cn.html）1、安装、卸载（1）安装1brew install jenkins（2）卸载1brew uninstall jenkins2、启用终端命令启动（仅对终端命令安装有效）：1jenkins开机自动启动：1ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents3、登录http://localhost:8080运行成功会在用户个人目录下新建.jenkins/文件夹访问localhost:8080就能到达Jenkins首页第一次需要从文件夹下获取生成的密码登录，复制粘贴密码验证成功后进入页面，选择插件模式大家都是默认选第一个稍等一会，插件安装好了进入用户登录界面，设定用户名、密码及邮箱。然后登陆就用你设置的用户名跟密码，记住哦！！配置项目的 jenkins job1、在 jenkins 左边栏点击 “新建”， 输入 job 名称，选择 “构建一个自由风格的软件项目” 一项。点击 “OK”2、进入 job ”配置“页面，点击 “General” 选项，配置名称和描述，我们用的github项目，那么勾选github并且填入项目地址3、点击 “源码管理” 选项，配置项目的 git 仓库地址的需要构建的分支信息4、点击 “构建触发器” 选项，配置 job 构建时机，勾选 “GitHub hook trigger for GITScm polling”，github hook 来触发 job 构建 ,这里没有暂时可以忽略5、点击 “构建” 选项，再点击 “增加构建步骤”， 选择 “Execute shell”，配置构建命令。 如下，这里配置了 npm install、npm run unit、npm run build, 分别做安装依赖、测试、打包三件事。后续继续补充","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://cansolve.cn/tags/服务器/"}]},{"title":"Eruda～一款移动端的调试神器","slug":"daily14","date":"2018-06-27T11:20:08.000Z","updated":"2018-12-26T07:41:43.990Z","comments":true,"path":"2018/06/27/daily14/","link":"","permalink":"http://cansolve.cn/2018/06/27/daily14/","excerpt":"","text":"昨天介绍了一下抓包工具 Charles的使用，今天再介绍一款移动端的调试面板；Eruda是什么？Eruda 是一个专为前端移动端、移动端设计的调试面板，类似Chrome DevTools的迷你版，其主要功能包括：捕获console日志、检查元素状态、显示性能指标、捕获XHR请求、显示本地存储和Cookie信息、浏览器特性检测等等。引用方式：1234567891011121314151617181920方式一 默认引入：&lt;script src=&quot;//cdn.jsdelivr.net/npm/eruda&quot;&gt;&lt;/script&gt;&lt;script&gt;eruda.init();&lt;/script&gt;方式二 动态加载：__DEBUG__ &amp;&amp; loadJS(&apos;http://cdn.jsdelivr.net/eruda/1.0.5/eruda.min.js&apos;, ()=&gt;&#123; eruda.init();&#125;);方式三 指定场景加载：;(function () &#123; var src = &apos;http://cdn.jsdelivr.net/eruda/1.0.5/eruda.min.js&apos;; if (!/eruda=true/.test(window.location) &amp;&amp; localStorage.getItem(&apos;active-eruda&apos;) != &apos;true&apos;) return; document.write(&apos;&lt;scr&apos; + &apos;ipt src=&quot;&apos; + src + &apos;&quot;&gt;&lt;/scr&apos; + &apos;ipt&gt;&apos;); document.write(&apos;&lt;scr&apos; + &apos;ipt&gt;eruda.init();&lt;/scr&apos; + &apos;ipt&gt;&apos;);&#125;)();方式四 npm： npm install eruda --save…… 加载的方式很多功能eruda能帮我们解决这个问题；所有的日志、错误都能帮我们捕获到，不要再去因为调试打印一堆的alert甚至我们还能像chrome,直接在控制台执行js代码；Elementseruda它没有在PC端这么直观，但也因为在移动端展示的方式局限性，它能把每一个父节点下的每一个子节点全部列出来；你点击某个子节点时，列出当前节点全部的属性、样式、盒子模型等；查看标签内容及属性；查看Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。甚至也能使用Plugins插件，做到跟PC端一样，形成 dom tree；Network现在的项目大多都是前后端分享的形式了，前端处理的业务越来越多、各种请求资源等；干的越多承担责任也越多、锅也越多，又大又平的那种哦～所以Network的必要性不言而喻，它能捕获请求，查看发送数据、返回头、返回内容等信息，它对于我们平时前后端联调出现的问题定位是有很大帮助的，比如：后端说你请求参数少了，前端你看了代码逻辑没有问题，但在手机上就是调不通，Network 能很直接明了的看到你请求带了什么。Resources它跟 Chrome Devtools 里的Application+Source,两者的结合体；Resources 它能查看 Cookie、localStorage、sessionStorage等信息，并且还能执行清除操作（Application）；它还查看当前页面加载脚本及样式文件；查看页面加载过的图片等资源（Source）；好吧，感觉说的再多，也不如上图直接：Sources/InfoSources：查看页面源码；格式化html，css，js代码及json数据。Info：主要输出URL信息及User Agent；及其他的一些手机系统信息，同时也支持自定义输出内容哦。高阶用法以上刚才介绍的是它的一些基本的功能，也是我自己在工作中用的较多的；最近发现新版本功能要强大不少，之前一直用的1.0.5，好像是没有插件这一项的；大概看了一下，都蛮强大，包括上面的Dom tree,插件这部分并没有都实际应用过，所以也就不打肿脸充胖子了，有兴趣的同学可以自己看看。如果觉得已经的插件都满足不了你的需求，它还支持自定义插件自己编写。在贴一下原文地址eruda","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://cansolve.cn/tags/其他/"}]},{"title":"Charles抓包工具的使用","slug":"daily13","date":"2018-06-26T06:29:08.000Z","updated":"2018-12-26T06:44:07.586Z","comments":true,"path":"2018/06/26/daily13/","link":"","permalink":"http://cansolve.cn/2018/06/26/daily13/","excerpt":"","text":"环境：mac OS X抓取苹果手机（ios）app里面的https请求包，对数据进行排查。Charles支持针对Https包解析。1.安装Charles2.电脑安装Charles证书电脑安装证书双击还是信任下吧3.手机安装证书手机安装证书4.手机网页输入网址 下载证书并信任1https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/或者直接在safari 浏览器打开下面的地址就可以下载1https://www.charlesproxy.com/assets/legacy-ssl/charles.crt手机证书下载网址安装到手机上注意：在iOS 10.3之前,当你将安装一个自定义证书,iOS会默认信任,不需要进一步的设置。而iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。iOS11下需要手动信任已下载好的证书，方法如下：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可.iOS11下手动信任证书5.开始抓包Charles设置ProxyProxy -&gt; SSL Proxying Settings…，如下图所示：疑问1，如果设置成特定的域名发现还是抓不了包，不知道为什么选择Proxy | Recording Settings，弹出Recording Settings设置选项卡，勾选include抓包这里贴一个比较详细的过程补充：如果用户不选择信任安装Charles的CA证书，Charles也无法获取请求内容。还有一种，如果客户端内置了本身的CA证书，这时如果Charles把自己的证书发送给客户端，客户端会发现与程序内的证书不一致，不予通过，此时Charles也是无法获取信息的。Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://cansolve.cn/tags/其他/"}]},{"title":"常见 React 面试题","slug":"daily7","date":"2018-06-17T04:11:23.000Z","updated":"2018-12-24T06:27:50.161Z","comments":true,"path":"2018/06/17/daily7/","link":"","permalink":"http://cansolve.cn/2018/06/17/daily7/","excerpt":"","text":"作者：小胡https://github.com/nanhupatar/FEGuide/blob/master/框架/react.mdReact 中 keys 的作用是什么？Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。12345678render()&#123;return ( &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123; return &#123;item&#125; &#125;)&#125; )&#125;在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。调用 setState 之后发生了什么？在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。react 生命周期函数初始化阶段：getDefaultProps:获取实例的默认属性getInitialState:获取每个实例的初始化状态componentWillMount：组件即将被装载、渲染到页面上render:组件在这里生成虚拟的 DOM 节点componentDidMount:组件真正在被装载之后运行中状态：componentWillReceiveProps:组件将要接收到属性的时候调用shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）componentWillUpdate:组件即将更新不能修改属性和状态render:组件重新描绘componentDidUpdate:组件已经更新销毁阶段：componentWillUnmount:组件即将销毁shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。参考 React进阶—性能优化为什么虚拟 dom 会提高性能?(必考)虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。参考 如何理解虚拟 DOM?react diff 原理（常考，大厂必考）把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的 key 属性，方便比较。React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。参考：React 的 diff 算法React 中 refs 的作用是什么？Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：123456789101112131415class CustomForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(&quot;Input Value: &quot;, this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：1234567891011function CustomForm (&#123;handleSubmit&#125;) &#123; let inputElement return ( &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; inputElement = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; )&#125;如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？123456789101112&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Badge info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt;import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;// fetchUser take in a username returns a promise// which will resolve with that username&apos;s data.class Twitter extends Component &#123; // finish this&#125;如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用：1234567891011121314151617import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;class Twitter extends Component &#123; state = &#123; user: null, &#125; static propTypes = &#123; username: PropTypes.string.isRequired, &#125; componentDidMount () &#123; fetchUser(this.props.username) .then((user) =&gt; this.setState(&#123;user&#125;)) &#125; render () &#123; return this.props.children(this.state.user) &#125;&#125;这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可：12345&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Profile info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt;展示组件(Presentational component)和容器组件(Container component)之间有何不同展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。类组件(Class component)和函数式组件(Functional component)之间有何不同类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件(组件的)状态(state)和属性(props)之间有何不同State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。何为受控组件(controlled component)在 HTML 中，类似 &lt;input&gt;, &lt;textarea&gt; 和 &lt;select&gt; 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。何为高阶组件(higher order component)高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。为什么建议传递给 setState 的参数是一个 callback 而不是一个对象因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。除了在构造函数中绑定 this，还有其它方式吗你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。(在构造函数中)调用 super(props) 的目的是什么在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。应该在 React 组件的何处发起 Ajax 请求在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。描述事件在 React 中的处理方式。为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。createElement 和 cloneElement 有什么区别？React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。12345React.createElement( type, [props], [...children])React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。12345React.cloneElement( element, [props], [...children])React 中有三种构建组件的方式React.createClass()、ES6 class 和无状态函数。react 组件的划分业务组件技术组件？根据组件的职责通常把组件分为 UI 组件和容器组件。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。两者通过 React-Redux 提供 connect 方法联系起来。简述 flux 思想Flux 的最大特点，就是数据的”单向流动”。用户访问 ViewView 发出用户的 ActionDispatcher 收到 Action，要求 Store 进行相应的更新Store 更新后，发出一个”change”事件View 收到”change”事件后，更新页面React 项目用过什么脚手架（本题是开放性题目）creat-react-app Yeoman 等了解 redux 么，说一下 redux 把redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们redux 有什么缺点一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.cn/categories/分享/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cansolve.cn/tags/react/"}]},{"title":"滑向未来（现代 JS 与 CSS 滚动实现指南)","slug":"daily6","date":"2018-06-03T04:11:23.000Z","updated":"2018-12-18T11:13:26.305Z","comments":true,"path":"2018/06/03/daily6/","link":"","permalink":"http://cansolve.cn/2018/06/03/daily6/","excerpt":"","text":"英文： Evil Martians 译文：众成翻译/sea_ljfwww.zcfy.cc/article/scroll-to-the-future一些（网站）滚动的效果是如此令人着迷但你却不知该如何实现，本文将为你揭开它们的神秘面纱。我们将基于最新的技术与规范为你介绍最新的 JavaScript 与 CSS 特性，（当你付诸实践时，）将使你的页面滚动更平滑、美观且性能更好。大多数的网页的内容都无法在一屏内全部展现，因而（页面）滚动对于用户而言是必不可少的。对于前端工程师与 UX 设计师而言，跨浏览器提供良好的滚动体验，同时符合设计（要求），无疑是一个挑战。尽管 web 标准的发展速度远超从前，但代码的实现往往是落后的。下文将为你介绍一些常见的关于滚动的案例，检查一下你所用的解决方案是否被更优雅的方案所代替。消逝的滚动条在过去的三十年里，滚动条的外观不断改变以符合设计的趋势，设计师们为（滚动条的）颜色、阴影、上下箭头的形状与边框的圆角实验了多种风格。以下是 Windows 上的变化历程：（Windows 上的滚动条）在2011年，苹果设计师从 ios 上获得灵感，为如何定义“美观的”滚动条确定了方向。所有滚动条均从 Mac 电脑中消失，不再占据任何页面空间，只有在用户触发滚动时（滚动条）才会重新出现（有些用户会设置不隐藏滚动条）。（Mac 上的滚动条）滚动条安静地消逝并未引起苹果粉丝的不满，已经习惯了 iPhone 与 iPad 上滚动方式的用户很快地习惯了这一设计。大多数开发人员与设计师都认为这是一个“好消息”，因为计算滚动条的宽度可真是件苦差事。然而，我们生活在一个拥有众多操作系统与浏览器的世界中，它们（对于滚动）的实现各不相同。如果你和我们一样是一名 Web 开发者，你可不能把“滚动条问题”置之不理。以下将为你介绍一些小技巧，使你的用户在滚动时有更好的体验。隐藏但可滚动先来看看一个关于模态框的经典例子。当它被打开的时候，主页面应该停止滚动。在 CSS 中有如下的快捷实现方式：body{overflow: hidden;}但上述代码会带来一点不良的副作用：（注意红色剪头）在这个示例中，为了演示目的，我们在 Mac 系统中设置了强制显示滚动条，因而用户体验与 Windows 用户相似。我们该如何解决这个问题呢？如果我们知道滚动条的宽度，每次当模态框出现时，可在主页面的右边设置一点边距。由于不同的操作系统与浏览器对滚动条的宽度不一，因而获取它的宽度并不容易。在Mac 系统中，无论任何浏览器（滚动条）都是统一15px，然而 Windows 系统可会令开发者发狂：（“百花齐放”的宽度）注意，以上仅是 Windows 系统下基于当前最新版浏览器（测试所得）的结果。以前的（浏览器）版本（宽度）可能有所不同，也没人知道未来（滚动条的宽度）会如何变化。不同于猜测（滚动条的宽度），你可以通过 JavaScript 计算它的宽度（译者注：实测以下代码仅能测出原始的宽度，通过 CSS 改变了滚动条宽度后，以下代码也无法测出实际宽度）：constouter = document.createElement(‘div’);constinner = document.createElement(‘div’);outer.style.overflow = ‘scroll’;document.body.appendChild(outer);outer.appendChild(inner);constscrollbarWidth = outer.offsetWidth - inner.offsetWidth;document.body.removeChild(outer);尽管仅仅七行代码（就能测出滚动条的宽度），但有数行代码是操作 DOM 的。（为性能起见，）如非必要，尽量避免进行 DOM 操作。解决这个问题的另一个方法是在模态框出现时仍保留滚动条，以下是基于这思路的纯 CSS 实现：html{overflow-y: scroll;}尽管“模态框抖动”问题解决了，但整体的外观却被一个无法使用的滚动条影响了，这无疑是设计中的硬伤。在我们看来，更好的解决方案是完全地隐藏滚动条。纯粹用 CSS 也是可以实现的。该方法（达到的效果）和 macOS 的表现并不是完全一致，（当用户）滚动时滚动条仍然是不可见的。滚动条总是处于不可见状态，然而页面是可被滚动的。对于Chrome，Safari 和 Opera 而言，可以使用以下的 CSS：.container::-webkit-scrollbar{display: none;}IE 或 Edge 可用以下代码:.container{-ms-overflow-style: none;}至于 Firefox，很不幸，没有任何办法隐藏滚动条。正如你所见，并没有任何银弹。任何解决方案都有它的优点与缺点，应根据你项目的需要选择最合适的。外观争议需要承认的是，滚动条的样子在部分操作系统上并不好看。一些设计师喜欢完全掌控他们（所设计）应用的样式，任何一丝细节也不放过。在 GitHub 上有上百个库借助 JavaScript 取代系统滚动条的默认实现，以达到自定义的效果。但如果你想根据现有的浏览器定制一个滚动条呢？（很遗憾，）并没有通用的 API，每个浏览器都有其独特的代码实现。尽管5.5版本以后的 IE 浏览器允许你修改滚动条的样式，但它只允许你修改滚动条的颜色。以下是如何重新绘制（滚动条）拖动部分与箭头的代码：body{scrollbar-face-color: blue;}但只改变颜色对提高用户体验而言帮助不大。据此，WebKit 的开发者在2009年提出了（修改滚动条）样式的方案。以下是使用 -webkit 前缀在支持相关样式的浏览器中模拟 macOS 滚动条样式的代码：::-webkit-scrollbar{width: 8px;}::-webkit-scrollbar-thumb{background-color: #c1c1c1;border-radius: 4px;}Chrome、Safari、Opera 甚至于 UC 浏览器或者三星自带的桌面浏览器都支持（上述 CSS）。Edge 也有计划实现它们。但三年过去了，该计划仍在中等优先级中（而尚未被实现）。当我们讨论滚动条的定制时，Mozilla 基金会基本上是无视了设计师的需求。（有开发者在）17年前就已经提出了一个希望修改滚动条样式的请求。而就在几个月前，Jeff Griffiths（Firefox 浏览器总监）终于为这个问题作出了回答：“除非团队中有人对此有兴趣，否则我对此毫不关心。”公平地说，从 W3C 的角度看来，尽管 WebKit 的实现得到广泛的支持，但它仍然不是标准。现有的为滚动条修改样式的草案，是基于 IE 的：仅能修改它的颜色。伴随着请求如同 WebKit 一样支持滚动条样式修改 issue 的提交，争议仍在继续。如果你想影响 CSS 工作小组，是时候参与讨论了。也许这不是优先级最高的问题，但（如同 WebKit 一样修改滚动条样式）得到标准化后，能使很多前端工程师与设计师轻松很多。流畅的操作体验对于滚动而言，最常见的任务是登录页的导航（跳转）。通常，它是通过锚点链接来完成的。只需要知道元素的 id 即可：&lt;ahref=”#section”&gt;点击该链接会 跳 到（该锚点对应的）区块上，（然而） UX 设计师一般会坚持认为该过程应是平滑地运动的。GitHub 上有大量造好的轮子（帮你解决这个问题），然而它们或多或少都用到 JavaScript。（其实）只用一行代码也能实现同样的效果，最近DOM API 中的 Element.scrollIntoView() 可以通过传入配置对象来实现平滑滚动：elem.scrollIntoView({behavior: ‘smooth’});然而该属性兼容性较差且仍是通过脚本（来控制样式）。如有可能，应尽量少用额外的脚本。幸运的是，有一个全新的 CSS 属性（仍在工作草案中），可以用简单的一行代码改变整个页面滚动的行为。html{scroll-behavior: smooth;}结果如下:（从一个区块跳到另一个）（平滑地滚动）你可以在 codepen 上试验这个属性。在撰写本文时，scroll-behavior 仅在 Chrome、 Firefox 与 Opera 上被支持，但我们希望它能被广泛支持，因为使用 CSS （比使用 JavaScript）在解决页面滚动问题时优雅得多，并更符合“渐进增强”的模式。粘性 CSS另一个常见的需求是根据滚动方向动态地定住元素，即有名的“粘性（即 CSS 中的position: sticky）”效应。（一个粘性元素）在以前的日子里，要实现一个“粘性”元素需要编写复杂的滚动处理函数去计算元素的大小。（然而）该函数较难处理元素在“黏住”与“不黏住”之间微小的延迟，（通常会）导致（元素）抖动的出现。通过 JavaScript 来实行（“粘性”元素）也有性能上的问题，特别是在（需要）调用 [Element.getBoundingClientRect() ]时(https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)。不久之前，CSS 实现了 position: sticky 属性。只需通过指定（某方向上的）偏移量即可实现我们想要的效果。.element{position: sticky;top: 50px;}（编写上述代码后，）剩下的就交由浏览器实现即可。你可以在 codepen 上试验一下。撰写本文之时，position: sticky 在各式浏览器（包括移动端浏览器）上支持良好，所以如果你还在使用 JavaScript 去解决这个问题的话，是时候换成纯 CSS 的实现了。全面使用函数节流从浏览器的角度看来，滚动是一个事件，因此在 JavaScript 中是使用一个标准化的事件监听器 addEventListener 去处理它： ，window.addEventListener(‘scroll’,() =&gt; {constscrollTop = window.scrollY;/ doSomething with scrollTop /});用户往往高频率地滚动（页面），但如果滚动事件触发太频繁的话，会导致性能上的问题，可以通过使用函数节流这一技巧去优化它。window.addEventListener(‘scroll’,throttle(() =&gt; {constscrollTop = window.scrollY;/ doSomething with scrollTop /}));你需要定义一个节流函数包装原来的事件监听函数，（节流函数是）减少被包装函数的执行次数，只允许它在固定的时间间隔之内执行一次：functionthrottle(action,wait = 1000){let time = Date.now();returnfunction(){if((time + wait - Date.now()) &lt; 0){action();time = Date.now();}}}为了使（节流后的）滚动更平滑，你可以通过使用 window.requestAnimationFrame() 来实现函数节流：functionthrottle(action){let isRunning = false;returnfunction(){if(isRunning)return;isRunning = true;window.requestAnimationFrame(() =&gt; {action();isRunning = false;});}}当然，你可以通过现有的开源轮子来实现，就像 Lodash 一样。你可以访问 codepen 来看看上述解决方案与 Lodash 中的 _.throttle 之间的区别。使用哪个（开源库）并不重要，重要的是在需要的时候，记得优化你（页面中的）滚动处理函数。在视窗中显示当你需要实现图片懒加载或者无限滚动时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用 lement.getBoundingClientRect() ：window.addEventListener(‘scroll’,() =&gt; {constrect = elem.getBoundingClientRect();constinViewport = rect.bottom &gt; 0 &amp;&amp; rect.right &gt; 0 &amp;&amp;rect.left &lt; window.innerWidth &amp;&amp;rect.top &lt; window.innerHeight;});上述代码的问题在于每次调用 getBoundingClientRect 时都会触发回流，严重地影响了性能。在事件处理函数中调用（ getBoundingClientRect ）尤为糟糕，就算使用了函数节流（的技巧）也可能对性能没多大帮助。 （回流是指浏览器为局部或整体地重绘某个元素，需要重新计算该元素在文档中的位置与形状。）在2016年后，可以通过使用 Intersection Observer 这一 API 来解决问题。它允许你追踪目标元素与其祖先元素或视窗的交叉状态。此外，尽管只有一部分元素出现在视窗中，哪怕只有一像素，也可以选择触发回调函数：constobserver = newIntersectionObserver(callback,options);observer.observe(element);此 API 被广泛地支持，但仍有一些浏览器需要 polyfill。尽管如此，它仍是目前最好的解决方案。滚动边界问题如果你的弹框或下拉列表是可滚动的，那你务必要了解连锁滚动相关的问题：当用户滚动到（弹框或下拉列表）末尾（后再继续滚动时），整个页面都会开始滚动。（连锁滚动的表现）当滚动元素到达底部时，你可以通过（改变）页面的 overflow 属性或在滚动元素的滚动事件处理函数中取消默认行为来解决这问题。如果你选择使用 JavaScript （来处理），请记住要处理的不是“scroll（事件）”，而是每当用户使用鼠标滚轮或触摸板时触发的“wheel（事件）”：functionhandleOverscroll(event){constdelta = -event.deltaY;if(delta&lt; 0 &amp;&amp; elem.scrollHeight - elem.scrollTop){elem.scrollTop = elem.scrollHeight;event.preventDefault();returnfalse;}if(delta &gt; elem.scrollTop){elem.scrollTop = 0;event.preventDefault();returnfalse;}returntrue;}不幸的是，这个解决方案不太可靠。同时可能对（页面）性能产生负面影响。过度滚动对移动端的影响尤为严重。Loren Brichter 在 iOS 的 Tweetie 应用上创造了一个“下拉刷新”的新手势，这在 UX 社区中引起了轰动：包括 Twitter 与 Facebook 在内的各大应用纷纷采用了（相同的手势）。当这个特性出现在安卓端的 Chrome 浏览器中时，问题出现了：它会刷新整个页面而不是加载更多的内容，成为开发者在他们的应用中实现“下拉刷新”时的麻烦。CSS 通过 overscroll-behavior 这个新属性解决问题。它通过控制元素滚动到尽头时的行为来解决下拉刷新与连锁滚动所带来的问题，（它的属性值中）也包含针对不同平台特殊值：安卓的 glow 与 苹果系统中的 rubber band。现在，上面 GIF 中的问题，在 Chrome、Opera 或 Firefox 中可以通过以下一行代码来解决：.element{overscroll-behavior: contain;}公平地说，IE 与 Edge 实现了（它独有的） -ms-scroll-chaining 属性来控制连锁滚动，但它并不能处理所有的情况。幸运的是，根据这消息，微软的浏览器已经准备实现 overscroll-behavior 这一属性了。触屏之后触屏设备上的滚动（体验）是一个很大的话题，深入讨论需要另开一篇文章。然而，由于很多开发者忽略了这方面的内容，这里需要提及一下。（滚动手势无处不在，令人沉迷，以至于想出了如此疯狂的主意去解决“滚动上瘾”的问题。）周围的人在智能手机屏幕上上下移动他们的手指的频率是多少呢？经常这样对吧，当你阅读本文时，你很可能就在这么做。当你的手指在屏幕上移动时，你期待的是：页面内容平滑且流畅地移动。苹果公司开创了“惯性”滚动并拥有它的专利 。它讯速地成为了用户交互的标准并且我们对此已习以为常。但你也许已经注意到了，尽管移动端系统会为你实现页面上的惯性滚动，但当页面内某个元素发生滚动时，即使用户同样期待惯性滚动，但它并不会出现，这令人沮丧。这里有一个 CSS 的解决方案，但看起来更像是个 hack：.element{-webkit-overflow-scrolling: touch;}为什么这是个 hack 呢？首先，它只能在支持（webkit）前缀的浏览器上才能工作。其次，它只适用于触屏设备。最后，如果浏览器不支持的话，你就这样置之不理吗？但无论如何，这总归是一个解决方案，你可以试着使用它。在触屏设备上，另一个需要考虑的问题是开发者如何处理 touchstart 与 touchmove 事件触发时可能存在的性能问题，它对用户滚动体验的影响非常大。这里详细描述了整个问题。简单来说，现代的浏览器虽然知道如何使得滚动变得平滑，但为确认（滚动）事件处理函数中是否执行了 Event.preventDefault() 以取消默认行为，有时仍可能需要花费500毫秒来等待事件处理函数执行完毕。即使是一个空的事件监听器，从不取消任何行为，鉴于浏览器仍会期待 preventDefault 的调用，也会对性能造成负面影响。为了准确地告诉浏览器不必担心（事件处理函数中）取消了默认行为，在 WHATWG 的 DOM 标准中存在着一个不太显眼的特性（能解决这问题）。（它就是）Passive event listeners，浏览器对它的支持还是不错的。事件监听函数新接受一个可选的对象作为参数，告诉浏览器当事件触发时，事件处理函数永远不会取消默认行为。（当然，添加此参数后，）在事件处理函数中调用 preventDefault 将不再产生效果。element.addEventListener(‘touchstart’,e =&gt; {/ doSomething /},{passive: true});针对不支持该参数的浏览器，这里也有一个 polyfill 。这视频清晰地展示了此改进带来的影响。旧技术运行良好，为何还要改动？在现代互联网中，过渡地依赖 JavaScript 在各浏览器上实现相同的交互效果不再是合理的，“跨浏览器兼容性”已经成为过去式，更多的 CSS 属性与 DOM API 方法正逐步被各大浏览器所支持。在我们看来，当你的项目中，有特别酷炫的滚动效果时，渐进增强是最好的做法。你应该提供（给用户）所有（你能提供的）基础用户体验，并逐步在更先进的浏览器上提供更好的体验。必要时使用 polyfill，它们不会产生（不必要的）依赖，一旦（某个 polyfill 所支持的属性）得到广泛地支持，你就可以轻松地将它删掉。六个月之前，在本文尚未成文之时，之前我们描述的属性只被少量的浏览器所支持。而到了本文发表之时，这些属性已被广泛地支持。也许到了现在，当你上下翻阅本文之时，（之前不支持某些属性的）浏览器已经支持了该属性，这使得你编程更容易，并使你的应用打包出来体积更小。感谢阅读至此！查阅浏览器的更新日志，积极参与讨论，有助于 web 标准驶向正确的方向。祝大家一帆风顺，顺利滑（滚）向未来！","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.cn/categories/分享/"}],"tags":[{"name":"css","slug":"css","permalink":"http://cansolve.cn/tags/css/"}]},{"title":"用Hexo + github搭建自己的博客","slug":"daily1","date":"2018-04-02T11:25:46.000Z","updated":"2018-12-24T04:22:38.674Z","comments":true,"path":"2018/04/02/daily1/","link":"","permalink":"http://cansolve.cn/2018/04/02/daily1/","excerpt":"","text":"前言这是我第一次写这种类型的博客，也不叫什么博客，纯粹个人一些踩坑过程罢了，原先弄的前后端分离的开发流程想想太复杂，一个博客页面没啥必要，主要还是记录自己的一些心得，内容比较重要。话不多说，开搞！！！基于node和git安装node.js和git这个就不多说了，贴个地址快速开始1、找个文件夹下打开终端,输入hexo i blogName //blog是项目名 cd blogName //切换到站点根目录 hexo g //generetor的缩写 hexo s //server的缩写 2 打开浏览器输入localhost:4000查看：看到这个样子就说明成功了，这个就是hexo默认的博客主题。现在你已经可以在这个主题下写博客了。你还可以选择博客的主题theme选择主题我选的是Claudia1 . 在站点根目录输入git clone https://github.com/Haojen/hexo-theme-Claudia.git 2 . 完成后，打开根目录下的 _config.yml 文件， 找到 theme 字段，把landscape改为 Claudia3 . 在终端输入hexo clean //清除缓存 hexo g //重新生成代码 hexo s //部署到本地 //然后打开浏览器访问 localhost:4000 查看效果 这时候主题已经换了，主题里面的修改项自行查阅一下，很多都有注释上传到github没有github账号的，自行注册一个【很少人没有吧】完了继续下一步选择一个主题结束访问 xxxxx.github.io 会看到上面一样的页面修改文件注意！！！冒号的后面一定一定一定要有一个空格！！ 开始部署npm install hexo-deployer-git --save //先装个插件 hexo d // 部署的命令 网上有的教程说需要账号密码，我这边没遇到，所以就不方便截图了发布第一篇博客根目录下输入 ：hexo new &quot;postName&quot; //hexo n 也可以 //你自己的博客名称，名为postName.md的文件会建在目 //录/blog/source/_posts下。 文章编辑完成后，终端在根目录文件夹下，执行如下命令来发布:hexo g //生成静态页面，类似于打个包 hexo d //发布 这样就可以发布咯","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.cn/categories/个人/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://cansolve.cn/tags/建站/"}]}]}