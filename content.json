{"meta":{"title":"blog","subtitle":null,"description":"my blog","author":"tongxiang","url":"http://cansolve.github.io"},"pages":[{"title":"关于","date":"2018-12-13T08:15:25.000Z","updated":"2018-12-13T08:15:25.000Z","comments":false,"path":"about/index.html","permalink":"http://cansolve.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"全部分类","date":"2018-12-13T08:13:11.000Z","updated":"2018-12-13T08:13:11.000Z","comments":false,"path":"categories/index.html","permalink":"http://cansolve.github.io/categories/index.html","excerpt":"","text":""},{"title":"全部标签","date":"2018-12-13T08:13:04.000Z","updated":"2018-12-13T08:13:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://cansolve.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"viewport-fit解决iPhone X、XS、XS Max、XR刘海屏问题","slug":"daily2","date":"2018-10-10T03:28:29.000Z","updated":"2018-12-14T07:26:24.000Z","comments":true,"path":"2018/10/10/daily2/","link":"","permalink":"http://cansolve.github.io/2018/10/10/daily2/","excerpt":"","text":"一次活动页面发现的iPhone X、XS、XS Max、XR刘海屏问题起因：游戏内嵌内嵌H5页面，提供的webview容器是全屏的，所以H5页面要处理以上设备的刘海问题【烦】。尺寸了解我这里就不写了，尺寸问题我就不写了，顶楼电梯iPhone X 配备一个覆盖整个手机的全面屏,顶部的“刘海”突出来使得网站被限制在一个“安全区域”,在两侧边缘会出现白条儿。移除这个白条儿也不难,给 body 设置一个 background-color 就可以搞定。但是我们内嵌的游戏页面背景色有时候不好设置背景色为纯色，另一种方法就是添加 viewport-fit=cover meta 标签,将整个网站扩展到整个屏幕1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;iPhone XS等手机还未发布之前，我们也是跟着学做已经做一些兼容来搞定iPhoneX。这里只是横屏代码，竖屏同理；1var isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;这里我们判断如果是iPhone X，把顶部增加高度30px的容器垫高，避开刘海头区域，各种方式都可以padding-left、absolute、margin-left。。。你能想到的方法都可以，这样标题正好避开刘海头。因为自己当时还没有用iPhone X，只知道iPhone X有刘海头，不知道其他细节问题。又到一年一度的9月份，苹果发布了3X机系列，有同事在Mac下的iPhone模拟器访问，发现这个页面iPhone XS Max下有问题。看了一下上面文章发现尺寸不一样，当初只判断了iPhone X加垫高，其他几个机型都未判断，所以就很自然的写了新机型，加上判断：123456// iPhone X、iPhone XSvar isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;// iPhone XS Maxvar isIPhoneXSMax = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;// iPhone XRvar isIPhoneXR = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 2 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;原来代码是if(isIPhoneX)垫高，现在改成if(isIPhoneX || isIPhoneXSMax || isIPhoneXR)垫高。这里有个坑，官方提供的安全区域代码constant(safe-area-inset-top) env(safe-area-inset-top)，使用后都在刘海头下面，如图（黑灰色区域状态栏）：当初没有用安全区域代码，一方面是因为页面有悬浮容器，会悬浮到安全区域外部，兼容页面正文麻烦，另一方面就是正文内容靠下，离刘海头有一段距离，感觉太丑干脆不用。总结：依旧不用安全区域代码，如果要做刘海头，if(isIPhoneX || isIPhoneXSMax || isIPhoneXR) 垫高44px。备注：iPhone X、iPhone XS、iPhone XS Max刘海头高度30px，iPhone XR刘海头高度33px。本文提到的30px、33px、44px，均为initial-scale=1下，px是在通用属性下，用rem写页面的请自行转换。设计稿像素应该都需要乘以2倍或3倍。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.github.io/categories/个人/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.github.io/tags/移动端/"}]},{"title":"JavaScript中的this","slug":"daily5","date":"2018-09-22T08:11:23.000Z","updated":"2018-12-18T10:29:21.092Z","comments":true,"path":"2018/09/22/daily5/","link":"","permalink":"http://cansolve.github.io/2018/09/22/daily5/","excerpt":"","text":"原文链接：flaviocopes.com翻译：我可是兔子this在不同的地方被调用有不同的值。不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。this在严格模式下除了在声明的对象内被调用,this在严格模式下永远是undefined。注意我提到的是严格模式。如果不是在严格模式下 (在js的头部，你没有明确的添加&#39;use strict&#39;关键字 ), 那么你就处在非严格模式的状态下,this在这个环境下， 除了我下面提到的特殊案例外 ，this指代的是全局对象的值。在浏览器的上下文环境中，这个值就是window。在函数方法中的this方法就是以函数形式附属于一个对象。函数可以有不同的声明形式。下面就是其中的一种：1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;car.drive()//Driving a Ford Fiesta car!在这个例子中，使用了常规的函数声明的形式,this自动绑定为car这个对象。注意: 上面的函数声明是drive: function() {…这样声明的缩写12345678const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive: function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;和上面的例子一样的指代:1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;car.drive = function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)&#125;car.drive()//Driving a Ford Fiesta car!在同样的语境下，使用箭头函数来声明函数，this的指代是不一样的，它属于词法（静态）绑定:1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive: () =&gt; &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;car.drive()//Driving a undefined undefined car!使用箭头函数你不能在箭头函数中像其他正常的函数声明形式那样给函数绑定一个值来改变this的值。导致这个的主要原因是箭头函数的工作原理。this在箭头函数中是词法绑定的, 也就是说它的值仅取决于它在哪个对象下被定义。明确地传递一个对象来改变this的值JavaScript提供了一些方法来映射this所指代的对象，从而得到你想要的值。在函数声明的阶段，使用bind():1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;const drive = function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)&#125;.bind(car)drive()//Driving a Ford Fiesta car!你可以绑定一个已定义的对象来改变this的值:12345678910111213141516const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;const anotherCar = &#123; maker: &apos;Audi&apos;, model: &apos;A4&apos;&#125;car.drive.bind(anotherCar)()//Driving a Audi A4 car!使用call()或者apply(), 在函数调用阶段:1234567891011121314const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;const drive = function(kmh) &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car at $&#123;kmh&#125; km/h!)&#125;drive.call(car, 100)//Driving a Ford Fiesta car at 100 km/h!drive.apply(car, [100])//Driving a Ford Fiesta car at 100 km/h!第一个传递给call()或者apply()的参数是新的this所指代的值。 call() 和 apply()两个函数的差异在于第二个参数，apply() 接受的是一个数组来作为它的参数，而call() 函数接受的是一串参数列表。DOM事件处理函数的特殊案例在浏览器事件处理函数的时候,this指代的是HTML对象，像下面的这样：123document.querySelector(&apos;#button&apos;).addEventListener(&apos;click&apos;, function(e) &#123; console.log(this) //HTMLElement&#125;但你可以使用bind() 函数来改变this值：123456document.querySelector(&apos;#button&apos;).addEventListener( &apos;click&apos;, function(e) &#123; console.log(this) //Window if global, or your context &#125;.bind(this))","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.github.io/categories/分享/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.github.io/tags/移动端/"}]},{"title":"移动端滚动事件overflow-y:scroll使用心得","slug":"daily4","date":"2018-09-18T07:45:43.000Z","updated":"2018-12-18T08:06:30.332Z","comments":true,"path":"2018/09/18/daily4/","link":"","permalink":"http://cansolve.github.io/2018/09/18/daily4/","excerpt":"","text":"作者：夏大师https://www.cnblogs.com/xiahj/p/8036419.html1. -webkit-overflow-scrolling:touch是什么？MDN上是这样定义的：-webkit-overflow-scrolling属性控制元素在移动设备上是否使用滚动回弹效果.auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。在移动端上，在你用overflow-y:scorll属性的时候，你会发现滚动的效果很木，很慢，这时候可以使用-webkit-overflow-scrolling:touch这个属性，让滚动条产生滚动回弹的效果，就像ios原生的滚动条一样流畅。2. 解决safari布局抖动的例子想实现一个布局为header、main、bottom的布局，其中头部和底部通过fixed固定，中间部分通过滚动条滑动。如果目的是实现只要中间的内容超过屏幕高度时，中间内容会自动滚动的效果的话，main部分加上上下的padding，然后不需要自己添加任何滚动条属性，当超出高度时，body会自动产生滚动条。这样我们的目的其实是实现了的。但是在safari上，当超出高度，页面往下滑时，浏览器底部的工具栏会随着页面一起晃动（向下滚动时会拉起底部工具栏），造成了很不好的体验。所以我们想在中间的main部分加一个独立的滚动条。2.1 方案一在main上使用fixed定位，加上overflow-y属性。123456.main &#123; position: fixed; top: 50px; bottom: 50px; overflow-y: scroll;&#125;不过不推荐这个fixed方案，因为页面偶尔卡住不动，下面说到了这个问题。2.2 方案二中间的main不设定位，高度100%，再padding头部和尾部，其中头部和底部的定位设为absolute会比设为fixed体验更好（况且fix布局在移动端本来就有各种各样的问题，还是尽量避开:) ）。大致代码如下，仍是overflow-y和-webkit-overflow-scrolling，重点在于中间部分依照文本流布局。123456789html, body &#123; height: 100%;&#125;main &#123; padding: 50px 0; height: 100%; overflow-y: scroll; -webkit-overflow-scrolling: touch;&#125;3. 探究-webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug-webkit-overflow-scrolling:touch这个属性真的是各种坑，我研究这个属性已经大半年了，还没有发现能够在safari上完美使用无bug的例子。最常见的例子就是，在safari上，使用了-webkit-overflow-scrolling:touch之后，页面偶尔会卡住不动。在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。通过动态添加内容撑开容器，结果根本不能滑动的bug。在网上也看到了一些人在问这个问题，不过不多，国外倒是讨论的更多一点，描述如下。偶尔卡住的问题，解决方案网上众说纷纭，遇到了很多相同的说法，比如如果卡住不动的话，就加一个z-index，就能解决该问题的说法。在试了很多次之后，这种说法没有一次解决过这个问题。这个说法能够传播出来，可能是使用者当时在使用的时候遇到了-webkit-overflow-scrolling:touch点透或者层级的问题。所以该方案不具有适用性。所以这个东西真的让我很苦恼了很久，以致于那段时间所有的滚动条不是通过body自己滚动，就是使用iScroll这样的库，繁琐地让我几乎想要放弃移动web，拥抱hybrid，不过在stackoverflow潜水了很久之后，总结了以下几种解决方案：3.1 保证使用了该属性的元素上没有设置定位如果出现偶尔卡住不动的情况，那么在使用该属性的元素上不设置定位或者手动设置定位为static1position: static这样会解决部分因为定位(relative、fixed、absolute)导致的页面偶尔不能滚动的bug。但是滑动到顶部继续手指往下滑，或者到底部继续往上滑，还是会触发卡住的问题（其实是整个页面上下回弹），说他算bug，其实就是ios8以上的特性，如果滚动区域大一点，用户不会觉得这是bug，如果小了，用户会不知道发生了什么而卡住了。视频在这，有梯子的同学可以看一看https://www.youtube.com/watch?v=MkAVYbO_joo。3.2 如果添加动态内容页面不能滚动，让子元素height+1如果在-webkit-overflow-scrolling:touch属性的元素上，想通过动态添加内容来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。国内没有人讨论这个问题，国外倒是很多，例如下面的描述：收集了很多资料，用了之后，下面的方法真正的解决了我的问题，真是直呼神奇，方案如下图：图一：图二：方法就是在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。123main-inner &#123; min-height: calc(100% + 1px)&#125;你也可以直接加伪元素上：123main:after &#123; min-height: calc(100% + 1px)&#125;这个方案不得不说真的好用。。当然还有其他方案，不过要写js或者jq了，麻烦。3.3 为什么会有卡住不动的这个bug这个bug产生于ios8以上（不十分肯定，但在ios5~7上需要手动使用translateZ(0)打开硬件加速）Safari对于overflow-scrolling用了原生控件来实现。对于有-webkit-overflow-scrolling的网页，会创建一个UIScrollView，提供子layer给渲染模块使用。我想说作为一个苦逼的前端只能解决到这了。4. -webkit-overflow-scrolling:touch的其他坑除此之外，这个属性还有很多bug，包括且不限于以下几种：滚动中 scrollTop 属性不会变化手势可穿过其他元素触发元素滚动滚动时暂停其他 transition","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.github.io/categories/分享/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.github.io/tags/移动端/"}]},{"title":"基于react + bootstrap 的 react-admin","slug":"daily3","date":"2018-09-14T07:52:19.000Z","updated":"2018-12-18T09:16:49.973Z","comments":true,"path":"2018/09/14/daily3/","link":"","permalink":"http://cansolve.github.io/2018/09/14/daily3/","excerpt":"","text":"前言此 react-admin 项目是基于 bootstrap-ace 框架之上，用 react 全家桶 + bootstrap 的进行再次开发的，项目已经开源，项目地址在 github 上。框架效果预览 http://www.pydyun.com/other/ace/index.htmlgithub地址 github1. 后台管理主要项目结构123456789101112131415161718192021222324demo //项目名 -- dist //预编译，自动构建之后会生成的文件，默认初始化是没有当前这个文件 -- asserts //静态资源目录，css,font,image -- public //html模板文件 -- webpack //webpack配置文件 -- webpack.base.config.js //公用 -- webpack.dev.config.js //开发环境 -- webpack.prod.config.js //生产环境 -- src //js编写文件 -- index.js // 初始化js -- module // 基础UI模块目录 -- tools // js方法工具库目录 -- action // action 目录 -- component // 对应的模块 目录 -- dispatch // dispatch 目录 -- reducers // reducers 目录 -- index.js // 前端渲染 -- router.js // 前端路由 -- store.js // store 文件 -- .babelr //babel的校验文件 -- .eslintrc //js编写校验配置文件 -- .gitignore //git过滤文件 -- package.json //node 安装包文件 -- README.md //readme 文件2. 本地必须要有node和git环境webpack 4bootstrap + acereact 16react-router 4redux 3babelpromiseasync + await3. 项目开始先在对应的git先创建git仓库，比如：XX管理后台 demo 项目，然后 git clone 到本来的开发环境，进入当前项目目录，代码如入：12git clone ssh://git@github.com:cansolve/react-manage.gitcd demo或者12cd demogit remote add origin ssh://git@github.com:cansolve/react-manage.git这时，通过git来添加前端开发初始化的工程目录，代码如下：12git remote add base ssh://git@github.com:cansolve/react-manage.gitgit pull base master --allow-unrelated-histories然后可以推送到开发项目上面去，代码如下：123git add .git commit -m &apos;前端项目初始化&apos;git push origin demo到此，你的 demo 项目前端搭建和初始化已完毕，接下来你就可以开始 前端开发 了4. 本地项目开始先安装编译第三方的依赖包1npm install123//如果开发之前本地没有对应的server服务器，也可以用node搭个server服务器，默认是8080端口:127.0.0.1:8080,如果有的话，直接跳过这一步npm install -g http-serverhttp-server -c-14.1 开发环境生产环境中开发监听对应的文件修改1npm run start4.2 生产环境压缩生产对应的线上文件，生产 html css image font js 文件1npm run build4.3 前端的升级和更新后续当前项目的前端库升级，bug修复，版本更新，直接可以通过命令来实现1git pull base master如有改动跟本地开发的导致冲突，请手动处理冲突文件，然后push到对应项目中去。5. 项目组建介绍5.1 表格组建说明：这里表格已经写成组建形式，只需要传入对应的title及data 后台获取数据 即可渲染成表格，对应的可以选择排序、勾选、包括给详情加a标签功能;5.2 分页组建说明：分页组建，点击传入对应页码，支持输入跳转;5.3 日历组建说明：日历时间选择组建，点击展示日期列表，选择传给后台为时间戳格式;5.4 下拉选择组建说明：点击出现下拉框，支持搜索功能5.4 下拉选择【多选】组建说明：点击出现下拉框，多选功能5.4 树组建说明：传入对应的数据即可渲染成树5.4 双向选择组建说明：两边数据可以互通选择，支持一键全部选择，两边数据都支持搜索功能；具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；5. 最后因为这是本人自己依据creat-react-app搭建的，跟公司项目目录还是有一定区别的，包括本人写代码的一些不好的地方还请多指正。大神请绕道，放小弟一条生路，谢谢啦！！本人公众号 码上关注 不定期分享一些前端知识，一起相互交流学习。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.github.io/categories/个人/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cansolve.github.io/tags/react/"}]},{"title":"常见 React 面试题","slug":"daily7","date":"2018-06-17T04:11:23.000Z","updated":"2018-12-19T07:07:41.705Z","comments":true,"path":"2018/06/17/daily7/","link":"","permalink":"http://cansolve.github.io/2018/06/17/daily7/","excerpt":"","text":"作者：小胡https://github.com/nanhupatar/FEGuide/blob/master/框架/react.mdReact 中 keys 的作用是什么？Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。12345678render()&#123;return ( &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123; return &#123;item&#125; &#125;)&#125; )&#125;在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。调用 setState 之后发生了什么？在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。react 生命周期函数初始化阶段：getDefaultProps:获取实例的默认属性getInitialState:获取每个实例的初始化状态componentWillMount：组件即将被装载、渲染到页面上render:组件在这里生成虚拟的 DOM 节点componentDidMount:组件真正在被装载之后运行中状态：componentWillReceiveProps:组件将要接收到属性的时候调用shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）componentWillUpdate:组件即将更新不能修改属性和状态render:组件重新描绘componentDidUpdate:组件已经更新销毁阶段：componentWillUnmount:组件即将销毁shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。参考 React进阶—性能优化为什么虚拟 dom 会提高性能?(必考)虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。参考 如何理解虚拟 DOM?react diff 原理（常考，大厂必考）把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的 key 属性，方便比较。React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。参考：React 的 diff 算法React 中 refs 的作用是什么？Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：123456789101112131415class CustomForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(&quot;Input Value: &quot;, this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：1234567891011function CustomForm (&#123;handleSubmit&#125;) &#123; let inputElement return ( &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; inputElement = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; )&#125;如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？123456789101112&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Badge info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt;import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;// fetchUser take in a username returns a promise// which will resolve with that username&apos;s data.class Twitter extends Component &#123; // finish this&#125;如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用：1234567891011121314151617import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;class Twitter extends Component &#123; state = &#123; user: null, &#125; static propTypes = &#123; username: PropTypes.string.isRequired, &#125; componentDidMount () &#123; fetchUser(this.props.username) .then((user) =&gt; this.setState(&#123;user&#125;)) &#125; render () &#123; return this.props.children(this.state.user) &#125;&#125;这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可：12345&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Profile info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt;展示组件(Presentational component)和容器组件(Container component)之间有何不同展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。类组件(Class component)和函数式组件(Functional component)之间有何不同类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件(组件的)状态(state)和属性(props)之间有何不同State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。何为受控组件(controlled component)在 HTML 中，类似 &lt;input&gt;, &lt;textarea&gt; 和 &lt;select&gt; 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。何为高阶组件(higher order component)高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。为什么建议传递给 setState 的参数是一个 callback 而不是一个对象因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。除了在构造函数中绑定 this，还有其它方式吗你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。(在构造函数中)调用 super(props) 的目的是什么在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。应该在 React 组件的何处发起 Ajax 请求在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。描述事件在 React 中的处理方式。为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。createElement 和 cloneElement 有什么区别？React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。12345React.createElement( type, [props], [...children])React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。12345React.cloneElement( element, [props], [...children])React 中有三种构建组件的方式React.createClass()、ES6 class 和无状态函数。react 组件的划分业务组件技术组件？根据组件的职责通常把组件分为 UI 组件和容器组件。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。两者通过 React-Redux 提供 connect 方法联系起来。简述 flux 思想Flux 的最大特点，就是数据的”单向流动”。用户访问 ViewView 发出用户的 ActionDispatcher 收到 Action，要求 Store 进行相应的更新Store 更新后，发出一个”change”事件View 收到”change”事件后，更新页面React 项目用过什么脚手架（本题是开放性题目）creat-react-app Yeoman 等了解 redux 么，说一下 redux 把redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们redux 有什么缺点一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.github.io/categories/分享/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cansolve.github.io/tags/react/"}]},{"title":"滑向未来（现代 JS 与 CSS 滚动实现指南)","slug":"daily6","date":"2018-06-03T04:11:23.000Z","updated":"2018-12-18T11:13:26.305Z","comments":true,"path":"2018/06/03/daily6/","link":"","permalink":"http://cansolve.github.io/2018/06/03/daily6/","excerpt":"","text":"英文： Evil Martians 译文：众成翻译/sea_ljfwww.zcfy.cc/article/scroll-to-the-future一些（网站）滚动的效果是如此令人着迷但你却不知该如何实现，本文将为你揭开它们的神秘面纱。我们将基于最新的技术与规范为你介绍最新的 JavaScript 与 CSS 特性，（当你付诸实践时，）将使你的页面滚动更平滑、美观且性能更好。大多数的网页的内容都无法在一屏内全部展现，因而（页面）滚动对于用户而言是必不可少的。对于前端工程师与 UX 设计师而言，跨浏览器提供良好的滚动体验，同时符合设计（要求），无疑是一个挑战。尽管 web 标准的发展速度远超从前，但代码的实现往往是落后的。下文将为你介绍一些常见的关于滚动的案例，检查一下你所用的解决方案是否被更优雅的方案所代替。消逝的滚动条在过去的三十年里，滚动条的外观不断改变以符合设计的趋势，设计师们为（滚动条的）颜色、阴影、上下箭头的形状与边框的圆角实验了多种风格。以下是 Windows 上的变化历程：（Windows 上的滚动条）在2011年，苹果设计师从 ios 上获得灵感，为如何定义“美观的”滚动条确定了方向。所有滚动条均从 Mac 电脑中消失，不再占据任何页面空间，只有在用户触发滚动时（滚动条）才会重新出现（有些用户会设置不隐藏滚动条）。（Mac 上的滚动条）滚动条安静地消逝并未引起苹果粉丝的不满，已经习惯了 iPhone 与 iPad 上滚动方式的用户很快地习惯了这一设计。大多数开发人员与设计师都认为这是一个“好消息”，因为计算滚动条的宽度可真是件苦差事。然而，我们生活在一个拥有众多操作系统与浏览器的世界中，它们（对于滚动）的实现各不相同。如果你和我们一样是一名 Web 开发者，你可不能把“滚动条问题”置之不理。以下将为你介绍一些小技巧，使你的用户在滚动时有更好的体验。隐藏但可滚动先来看看一个关于模态框的经典例子。当它被打开的时候，主页面应该停止滚动。在 CSS 中有如下的快捷实现方式：body{overflow: hidden;}但上述代码会带来一点不良的副作用：（注意红色剪头）在这个示例中，为了演示目的，我们在 Mac 系统中设置了强制显示滚动条，因而用户体验与 Windows 用户相似。我们该如何解决这个问题呢？如果我们知道滚动条的宽度，每次当模态框出现时，可在主页面的右边设置一点边距。由于不同的操作系统与浏览器对滚动条的宽度不一，因而获取它的宽度并不容易。在Mac 系统中，无论任何浏览器（滚动条）都是统一15px，然而 Windows 系统可会令开发者发狂：（“百花齐放”的宽度）注意，以上仅是 Windows 系统下基于当前最新版浏览器（测试所得）的结果。以前的（浏览器）版本（宽度）可能有所不同，也没人知道未来（滚动条的宽度）会如何变化。不同于猜测（滚动条的宽度），你可以通过 JavaScript 计算它的宽度（译者注：实测以下代码仅能测出原始的宽度，通过 CSS 改变了滚动条宽度后，以下代码也无法测出实际宽度）：constouter = document.createElement(‘div’);constinner = document.createElement(‘div’);outer.style.overflow = ‘scroll’;document.body.appendChild(outer);outer.appendChild(inner);constscrollbarWidth = outer.offsetWidth - inner.offsetWidth;document.body.removeChild(outer);尽管仅仅七行代码（就能测出滚动条的宽度），但有数行代码是操作 DOM 的。（为性能起见，）如非必要，尽量避免进行 DOM 操作。解决这个问题的另一个方法是在模态框出现时仍保留滚动条，以下是基于这思路的纯 CSS 实现：html{overflow-y: scroll;}尽管“模态框抖动”问题解决了，但整体的外观却被一个无法使用的滚动条影响了，这无疑是设计中的硬伤。在我们看来，更好的解决方案是完全地隐藏滚动条。纯粹用 CSS 也是可以实现的。该方法（达到的效果）和 macOS 的表现并不是完全一致，（当用户）滚动时滚动条仍然是不可见的。滚动条总是处于不可见状态，然而页面是可被滚动的。对于Chrome，Safari 和 Opera 而言，可以使用以下的 CSS：.container::-webkit-scrollbar{display: none;}IE 或 Edge 可用以下代码:.container{-ms-overflow-style: none;}至于 Firefox，很不幸，没有任何办法隐藏滚动条。正如你所见，并没有任何银弹。任何解决方案都有它的优点与缺点，应根据你项目的需要选择最合适的。外观争议需要承认的是，滚动条的样子在部分操作系统上并不好看。一些设计师喜欢完全掌控他们（所设计）应用的样式，任何一丝细节也不放过。在 GitHub 上有上百个库借助 JavaScript 取代系统滚动条的默认实现，以达到自定义的效果。但如果你想根据现有的浏览器定制一个滚动条呢？（很遗憾，）并没有通用的 API，每个浏览器都有其独特的代码实现。尽管5.5版本以后的 IE 浏览器允许你修改滚动条的样式，但它只允许你修改滚动条的颜色。以下是如何重新绘制（滚动条）拖动部分与箭头的代码：body{scrollbar-face-color: blue;}但只改变颜色对提高用户体验而言帮助不大。据此，WebKit 的开发者在2009年提出了（修改滚动条）样式的方案。以下是使用 -webkit 前缀在支持相关样式的浏览器中模拟 macOS 滚动条样式的代码：::-webkit-scrollbar{width: 8px;}::-webkit-scrollbar-thumb{background-color: #c1c1c1;border-radius: 4px;}Chrome、Safari、Opera 甚至于 UC 浏览器或者三星自带的桌面浏览器都支持（上述 CSS）。Edge 也有计划实现它们。但三年过去了，该计划仍在中等优先级中（而尚未被实现）。当我们讨论滚动条的定制时，Mozilla 基金会基本上是无视了设计师的需求。（有开发者在）17年前就已经提出了一个希望修改滚动条样式的请求。而就在几个月前，Jeff Griffiths（Firefox 浏览器总监）终于为这个问题作出了回答：“除非团队中有人对此有兴趣，否则我对此毫不关心。”公平地说，从 W3C 的角度看来，尽管 WebKit 的实现得到广泛的支持，但它仍然不是标准。现有的为滚动条修改样式的草案，是基于 IE 的：仅能修改它的颜色。伴随着请求如同 WebKit 一样支持滚动条样式修改 issue 的提交，争议仍在继续。如果你想影响 CSS 工作小组，是时候参与讨论了。也许这不是优先级最高的问题，但（如同 WebKit 一样修改滚动条样式）得到标准化后，能使很多前端工程师与设计师轻松很多。流畅的操作体验对于滚动而言，最常见的任务是登录页的导航（跳转）。通常，它是通过锚点链接来完成的。只需要知道元素的 id 即可：&lt;ahref=”#section”&gt;点击该链接会 跳 到（该锚点对应的）区块上，（然而） UX 设计师一般会坚持认为该过程应是平滑地运动的。GitHub 上有大量造好的轮子（帮你解决这个问题），然而它们或多或少都用到 JavaScript。（其实）只用一行代码也能实现同样的效果，最近DOM API 中的 Element.scrollIntoView() 可以通过传入配置对象来实现平滑滚动：elem.scrollIntoView({behavior: ‘smooth’});然而该属性兼容性较差且仍是通过脚本（来控制样式）。如有可能，应尽量少用额外的脚本。幸运的是，有一个全新的 CSS 属性（仍在工作草案中），可以用简单的一行代码改变整个页面滚动的行为。html{scroll-behavior: smooth;}结果如下:（从一个区块跳到另一个）（平滑地滚动）你可以在 codepen 上试验这个属性。在撰写本文时，scroll-behavior 仅在 Chrome、 Firefox 与 Opera 上被支持，但我们希望它能被广泛支持，因为使用 CSS （比使用 JavaScript）在解决页面滚动问题时优雅得多，并更符合“渐进增强”的模式。粘性 CSS另一个常见的需求是根据滚动方向动态地定住元素，即有名的“粘性（即 CSS 中的position: sticky）”效应。（一个粘性元素）在以前的日子里，要实现一个“粘性”元素需要编写复杂的滚动处理函数去计算元素的大小。（然而）该函数较难处理元素在“黏住”与“不黏住”之间微小的延迟，（通常会）导致（元素）抖动的出现。通过 JavaScript 来实行（“粘性”元素）也有性能上的问题，特别是在（需要）调用 [Element.getBoundingClientRect() ]时(https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)。不久之前，CSS 实现了 position: sticky 属性。只需通过指定（某方向上的）偏移量即可实现我们想要的效果。.element{position: sticky;top: 50px;}（编写上述代码后，）剩下的就交由浏览器实现即可。你可以在 codepen 上试验一下。撰写本文之时，position: sticky 在各式浏览器（包括移动端浏览器）上支持良好，所以如果你还在使用 JavaScript 去解决这个问题的话，是时候换成纯 CSS 的实现了。全面使用函数节流从浏览器的角度看来，滚动是一个事件，因此在 JavaScript 中是使用一个标准化的事件监听器 addEventListener 去处理它： ，window.addEventListener(‘scroll’,() =&gt; {constscrollTop = window.scrollY;/ doSomething with scrollTop /});用户往往高频率地滚动（页面），但如果滚动事件触发太频繁的话，会导致性能上的问题，可以通过使用函数节流这一技巧去优化它。window.addEventListener(‘scroll’,throttle(() =&gt; {constscrollTop = window.scrollY;/ doSomething with scrollTop /}));你需要定义一个节流函数包装原来的事件监听函数，（节流函数是）减少被包装函数的执行次数，只允许它在固定的时间间隔之内执行一次：functionthrottle(action,wait = 1000){let time = Date.now();returnfunction(){if((time + wait - Date.now()) &lt; 0){action();time = Date.now();}}}为了使（节流后的）滚动更平滑，你可以通过使用 window.requestAnimationFrame() 来实现函数节流：functionthrottle(action){let isRunning = false;returnfunction(){if(isRunning)return;isRunning = true;window.requestAnimationFrame(() =&gt; {action();isRunning = false;});}}当然，你可以通过现有的开源轮子来实现，就像 Lodash 一样。你可以访问 codepen 来看看上述解决方案与 Lodash 中的 _.throttle 之间的区别。使用哪个（开源库）并不重要，重要的是在需要的时候，记得优化你（页面中的）滚动处理函数。在视窗中显示当你需要实现图片懒加载或者无限滚动时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用 lement.getBoundingClientRect() ：window.addEventListener(‘scroll’,() =&gt; {constrect = elem.getBoundingClientRect();constinViewport = rect.bottom &gt; 0 &amp;&amp; rect.right &gt; 0 &amp;&amp;rect.left &lt; window.innerWidth &amp;&amp;rect.top &lt; window.innerHeight;});上述代码的问题在于每次调用 getBoundingClientRect 时都会触发回流，严重地影响了性能。在事件处理函数中调用（ getBoundingClientRect ）尤为糟糕，就算使用了函数节流（的技巧）也可能对性能没多大帮助。 （回流是指浏览器为局部或整体地重绘某个元素，需要重新计算该元素在文档中的位置与形状。）在2016年后，可以通过使用 Intersection Observer 这一 API 来解决问题。它允许你追踪目标元素与其祖先元素或视窗的交叉状态。此外，尽管只有一部分元素出现在视窗中，哪怕只有一像素，也可以选择触发回调函数：constobserver = newIntersectionObserver(callback,options);observer.observe(element);此 API 被广泛地支持，但仍有一些浏览器需要 polyfill。尽管如此，它仍是目前最好的解决方案。滚动边界问题如果你的弹框或下拉列表是可滚动的，那你务必要了解连锁滚动相关的问题：当用户滚动到（弹框或下拉列表）末尾（后再继续滚动时），整个页面都会开始滚动。（连锁滚动的表现）当滚动元素到达底部时，你可以通过（改变）页面的 overflow 属性或在滚动元素的滚动事件处理函数中取消默认行为来解决这问题。如果你选择使用 JavaScript （来处理），请记住要处理的不是“scroll（事件）”，而是每当用户使用鼠标滚轮或触摸板时触发的“wheel（事件）”：functionhandleOverscroll(event){constdelta = -event.deltaY;if(delta&lt; 0 &amp;&amp; elem.scrollHeight - elem.scrollTop){elem.scrollTop = elem.scrollHeight;event.preventDefault();returnfalse;}if(delta &gt; elem.scrollTop){elem.scrollTop = 0;event.preventDefault();returnfalse;}returntrue;}不幸的是，这个解决方案不太可靠。同时可能对（页面）性能产生负面影响。过度滚动对移动端的影响尤为严重。Loren Brichter 在 iOS 的 Tweetie 应用上创造了一个“下拉刷新”的新手势，这在 UX 社区中引起了轰动：包括 Twitter 与 Facebook 在内的各大应用纷纷采用了（相同的手势）。当这个特性出现在安卓端的 Chrome 浏览器中时，问题出现了：它会刷新整个页面而不是加载更多的内容，成为开发者在他们的应用中实现“下拉刷新”时的麻烦。CSS 通过 overscroll-behavior 这个新属性解决问题。它通过控制元素滚动到尽头时的行为来解决下拉刷新与连锁滚动所带来的问题，（它的属性值中）也包含针对不同平台特殊值：安卓的 glow 与 苹果系统中的 rubber band。现在，上面 GIF 中的问题，在 Chrome、Opera 或 Firefox 中可以通过以下一行代码来解决：.element{overscroll-behavior: contain;}公平地说，IE 与 Edge 实现了（它独有的） -ms-scroll-chaining 属性来控制连锁滚动，但它并不能处理所有的情况。幸运的是，根据这消息，微软的浏览器已经准备实现 overscroll-behavior 这一属性了。触屏之后触屏设备上的滚动（体验）是一个很大的话题，深入讨论需要另开一篇文章。然而，由于很多开发者忽略了这方面的内容，这里需要提及一下。（滚动手势无处不在，令人沉迷，以至于想出了如此疯狂的主意去解决“滚动上瘾”的问题。）周围的人在智能手机屏幕上上下移动他们的手指的频率是多少呢？经常这样对吧，当你阅读本文时，你很可能就在这么做。当你的手指在屏幕上移动时，你期待的是：页面内容平滑且流畅地移动。苹果公司开创了“惯性”滚动并拥有它的专利 。它讯速地成为了用户交互的标准并且我们对此已习以为常。但你也许已经注意到了，尽管移动端系统会为你实现页面上的惯性滚动，但当页面内某个元素发生滚动时，即使用户同样期待惯性滚动，但它并不会出现，这令人沮丧。这里有一个 CSS 的解决方案，但看起来更像是个 hack：.element{-webkit-overflow-scrolling: touch;}为什么这是个 hack 呢？首先，它只能在支持（webkit）前缀的浏览器上才能工作。其次，它只适用于触屏设备。最后，如果浏览器不支持的话，你就这样置之不理吗？但无论如何，这总归是一个解决方案，你可以试着使用它。在触屏设备上，另一个需要考虑的问题是开发者如何处理 touchstart 与 touchmove 事件触发时可能存在的性能问题，它对用户滚动体验的影响非常大。这里详细描述了整个问题。简单来说，现代的浏览器虽然知道如何使得滚动变得平滑，但为确认（滚动）事件处理函数中是否执行了 Event.preventDefault() 以取消默认行为，有时仍可能需要花费500毫秒来等待事件处理函数执行完毕。即使是一个空的事件监听器，从不取消任何行为，鉴于浏览器仍会期待 preventDefault 的调用，也会对性能造成负面影响。为了准确地告诉浏览器不必担心（事件处理函数中）取消了默认行为，在 WHATWG 的 DOM 标准中存在着一个不太显眼的特性（能解决这问题）。（它就是）Passive event listeners，浏览器对它的支持还是不错的。事件监听函数新接受一个可选的对象作为参数，告诉浏览器当事件触发时，事件处理函数永远不会取消默认行为。（当然，添加此参数后，）在事件处理函数中调用 preventDefault 将不再产生效果。element.addEventListener(‘touchstart’,e =&gt; {/ doSomething /},{passive: true});针对不支持该参数的浏览器，这里也有一个 polyfill 。这视频清晰地展示了此改进带来的影响。旧技术运行良好，为何还要改动？在现代互联网中，过渡地依赖 JavaScript 在各浏览器上实现相同的交互效果不再是合理的，“跨浏览器兼容性”已经成为过去式，更多的 CSS 属性与 DOM API 方法正逐步被各大浏览器所支持。在我们看来，当你的项目中，有特别酷炫的滚动效果时，渐进增强是最好的做法。你应该提供（给用户）所有（你能提供的）基础用户体验，并逐步在更先进的浏览器上提供更好的体验。必要时使用 polyfill，它们不会产生（不必要的）依赖，一旦（某个 polyfill 所支持的属性）得到广泛地支持，你就可以轻松地将它删掉。六个月之前，在本文尚未成文之时，之前我们描述的属性只被少量的浏览器所支持。而到了本文发表之时，这些属性已被广泛地支持。也许到了现在，当你上下翻阅本文之时，（之前不支持某些属性的）浏览器已经支持了该属性，这使得你编程更容易，并使你的应用打包出来体积更小。感谢阅读至此！查阅浏览器的更新日志，积极参与讨论，有助于 web 标准驶向正确的方向。祝大家一帆风顺，顺利滑（滚）向未来！","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.github.io/categories/分享/"}],"tags":[{"name":"css","slug":"css","permalink":"http://cansolve.github.io/tags/css/"}]},{"title":"用Hexo + github搭建自己的博客","slug":"daily1","date":"2018-04-02T11:25:46.000Z","updated":"2018-12-14T07:27:02.000Z","comments":true,"path":"2018/04/02/daily1/","link":"","permalink":"http://cansolve.github.io/2018/04/02/daily1/","excerpt":"","text":"前言这是我第一次写这种类型的博客，也不叫什么博客，纯粹个人一些踩坑过程罢了，原先弄的前后端分离的开发流程想想太复杂，一个博客页面没啥必要，主要还是记录自己的一些心得，内容比较重要。话不多说，开搞！！！基于node和git安装node.js和git这个就不多说了，贴个地址快速开始1、找个文件夹下打开终端,输入hexo i blogName //blog是项目名 cd blogName //切换到站点根目录 hexo g //generetor的缩写 hexo s //server的缩写 2 打开浏览器输入localhost:4000查看：看到这个样子就说明成功了，这个就是hexo默认的博客主题。现在你已经可以在这个主题下写博客了。你还可以选择博客的主题theme选择主题我选的是Claudia1 . 在站点根目录输入git clone https://github.com/Haojen/hexo-theme-Claudia.git 2 . 完成后，打开根目录下的 _config.yml 文件， 找到 theme 字段，把landscape改为 Claudia3 . 在终端输入hexo clean //清除缓存 hexo g //重新生成代码 hexo s //部署到本地 //然后打开浏览器访问 localhost:4000 查看效果 这时候主题已经换了，主题里面的修改项自行查阅一下，很多都有注释上传到github没有github账号的，自行注册一个【很少人没有吧】完了继续下一步选择一个主题结束访问 xxxxx.github.io 会看到上面一样的页面修改文件注意！！！冒号的后面一定一定一定要有一个空格！！ 开始部署npm install hexo-deployer-git --save //先装个插件 hexo d // 部署的命令 网上有的教程说需要账号密码，我这边没遇到，所以就不方便截图了发布第一篇博客根目录下输入 ：hexo new &quot;postName&quot; //hexo n 也可以 //你自己的博客名称，名为postName.md的文件会建在目 //录/blog/source/_posts下。 文章编辑完成后，终端在根目录文件夹下，执行如下命令来发布:hexo g //生成静态页面，类似于打个包 hexo d //发布 这样就可以发布咯","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.github.io/categories/个人/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://cansolve.github.io/tags/建站/"}]}]}